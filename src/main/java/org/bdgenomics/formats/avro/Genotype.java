/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bdgenomics.formats.avro;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class Genotype extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Genotype\",\"namespace\":\"org.bdgenomics.formats.avro\",\"fields\":[{\"name\":\"variant\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Variant\",\"fields\":[{\"name\":\"variantErrorProbability\",\"type\":[\"null\",\"int\"],\"doc\":\"The Phred scaled error probability of a variant, given the probabilities of\\n   the variant in a population.\",\"default\":null},{\"name\":\"contig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Contig\",\"doc\":\"Record for describing a reference assembly. Not used for storing the contents\\n of said assembly.\\n\\n @see NucleotideContigFragment\",\"fields\":[{\"name\":\"contigName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this contig in the assembly (e.g., \\\"chr1\\\").\",\"default\":null},{\"name\":\"contigLength\",\"type\":[\"null\",\"long\"],\"doc\":\"The length of this contig.\",\"default\":null},{\"name\":\"contigMD5\",\"type\":[\"null\",\"string\"],\"doc\":\"The MD5 checksum of the assembly for this contig.\",\"default\":null},{\"name\":\"referenceURL\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL at which this reference assembly can be found.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this assembly (e.g., \\\"hg19\\\").\",\"default\":null},{\"name\":\"species\",\"type\":[\"null\",\"string\"],\"doc\":\"The species that this assembly is for.\",\"default\":null},{\"name\":\"referenceIndex\",\"type\":[\"null\",\"int\"],\"doc\":\"Optional 0-based index of this contig in a SAM file header that it was read\\n   from; helps output SAMs/BAMs with headers in the same order as they started\\n   with, before a conversion to ADAM.\",\"default\":null}]}],\"doc\":\"The reference contig that this variant exists on.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"The 0-based start position of this variant on the reference contig.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"The 0-based, exclusive end position of this variant on the reference contig.\",\"default\":null},{\"name\":\"referenceAllele\",\"type\":[\"null\",\"string\"],\"doc\":\"A string describing the reference allele at this site.\",\"default\":null},{\"name\":\"alternateAllele\",\"type\":[\"null\",\"string\"],\"doc\":\"A string describing the variant allele at this site. Should be left null if\\n   the site is a structural variant.\",\"default\":null},{\"name\":\"svAllele\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"StructuralVariant\",\"fields\":[{\"name\":\"type\",\"type\":[\"null\",{\"type\":\"enum\",\"name\":\"StructuralVariantType\",\"doc\":\"Descriptors for the type of a structural variant. The most specific descriptor\\n should be used, if possible. E.g., duplication should be used instead of\\n insertion if the inserted sequence is not novel. Tandem duplication should\\n be used instead of duplication if the duplication is known to follow the\\n duplicated sequence.\",\"symbols\":[\"DELETION\",\"INSERTION\",\"INVERSION\",\"MOBILE_INSERTION\",\"MOBILE_DELETION\",\"DUPLICATION\",\"TANDEM_DUPLICATION\"]}],\"doc\":\"The type of this structural variant.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL of the FASTA/NucleotideContig assembly for this structural variant,\\n   if one is available.\",\"default\":null},{\"name\":\"precise\",\"type\":[\"boolean\",\"null\"],\"doc\":\"Whether this structural variant call has precise breakpoints or not. Default\\n   value is true. If the call is imprecise, confidence intervals should be provided.\",\"default\":true},{\"name\":\"startWindow\",\"type\":[\"null\",\"int\"],\"doc\":\"The size of the confidence window around the start of the structural variant.\",\"default\":null},{\"name\":\"endWindow\",\"type\":[\"null\",\"int\"],\"doc\":\"The size of the confidence window around the end of the structural variant.\",\"default\":null}]}],\"doc\":\"The structural variant at this site, if the alternate allele is a structural\\n   variant. If the site is not a structural variant, this field should be left\\n   null.\",\"default\":null},{\"name\":\"isSomatic\",\"type\":[\"boolean\",\"null\"],\"doc\":\"A boolean describing whether this variant call is somatic; in this case, the\\n   `referenceAllele` will have been observed in another sample.\",\"default\":false}]}],\"doc\":\"The variant called at this site.\",\"default\":null},{\"name\":\"variantCallingAnnotations\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"VariantCallingAnnotations\",\"fields\":[{\"name\":\"variantIsPassing\",\"type\":[\"null\",\"boolean\"],\"default\":null},{\"name\":\"variantFilters\",\"type\":{\"type\":\"array\",\"items\":\"string\"},\"default\":[]},{\"name\":\"downsampled\",\"type\":[\"null\",\"boolean\"],\"doc\":\"True if the reads covering this site were randomly downsampled to reduce coverage.\",\"default\":null},{\"name\":\"baseQRankSum\",\"type\":[\"null\",\"float\"],\"doc\":\"The Wilcoxon rank-sum test statistic of the base quality scores. The base quality\\n   scores are separated by whether or not the base supports the reference or the\\n   alternate allele.\",\"default\":null},{\"name\":\"fisherStrandBiasPValue\",\"type\":[\"null\",\"float\"],\"doc\":\"The Fisher's exact test score for the strand bias of the reference and alternate\\n   alleles. Stored as a phred scaled probability. Thus, if:\\n\\n   * a = The number of positive strand reads covering the reference allele\\n   * b = The number of positive strand reads covering the alternate allele\\n   * c = The number of negative strand reads covering the reference allele\\n   * d = The number of negative strand reads covering the alternate allele\\n\\n   This value takes the score:\\n   \\n   -10 log((a + b)! * (c + d)! * (a + c)! * (b + d)! / (a! b! c! d! n!)\\n\\n   Where n = a + b + c + d.\",\"default\":null},{\"name\":\"rmsMapQ\",\"type\":[\"null\",\"float\"],\"doc\":\"The root mean square of the mapping qualities of reads covering this site.\",\"default\":null},{\"name\":\"mapq0Reads\",\"type\":[\"null\",\"int\"],\"doc\":\"The number of reads at this site with mapping quality equal to 0.\",\"default\":null},{\"name\":\"mqRankSum\",\"type\":[\"null\",\"float\"],\"doc\":\"The Wilcoxon rank-sum test statistic of the mapping quality scores. The mapping\\n   quality scores are separated by whether or not the read supported the reference or the\\n   alternate allele.\",\"default\":null},{\"name\":\"readPositionRankSum\",\"type\":[\"null\",\"float\"],\"doc\":\"The Wilcoxon rank-sum test statistic of the position of the base in the read at this site.\\n   The positions are separated by whether or not the base supports the reference or the\\n   alternate allele.\",\"default\":null},{\"name\":\"genotypePriors\",\"type\":{\"type\":\"array\",\"items\":\"float\"},\"doc\":\"The log scale prior probabilities of the various genotype states at this site.\\n   The number of elements in this array should be equal to the ploidy at this\\n   site, plus 1.\",\"default\":[]},{\"name\":\"genotypePosteriors\",\"type\":{\"type\":\"array\",\"items\":\"float\"},\"doc\":\"The log scaled posterior probabilities of the various genotype states at this site,\\n   in this sample. The number of elements in this array should be equal to the ploidy at\\n   this site, plus 1.\",\"default\":[]},{\"name\":\"vqslod\",\"type\":[\"null\",\"float\"],\"doc\":\"The log-odds ratio of being a true vs. false variant under a trained statistical model.\\n    This model can be a multivariate Gaussian mixture, support vector machine, etc.\",\"default\":null},{\"name\":\"culprit\",\"type\":[\"null\",\"string\"],\"doc\":\"If known, the feature that contributed the most to this variant being classified as\\n   a false variant.\",\"default\":null},{\"name\":\"attributes\",\"type\":{\"type\":\"map\",\"values\":\"string\"},\"doc\":\"Additional feature info that doesn't fit into the standard fields above.\\n\\n   They are all encoded as (string, string) key-value pairs.\",\"default\":{}}]}],\"doc\":\"Statistics collected at this site, if available.\",\"default\":null},{\"name\":\"sampleId\",\"type\":[\"null\",\"string\"],\"doc\":\"The unique identifier for this sample.\",\"default\":null},{\"name\":\"sampleDescription\",\"type\":[\"null\",\"string\"],\"doc\":\"A description of this sample.\",\"default\":null},{\"name\":\"processingDescription\",\"type\":[\"null\",\"string\"],\"doc\":\"A string describing the provenance of this sample and the processing applied\\n   in genotyping this sample.\",\"default\":null},{\"name\":\"alleles\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"enum\",\"name\":\"GenotypeAllele\",\"doc\":\"An enumeration that describes the allele that corresponds to a genotype. Can take\\n the following values:\\n\\n * Ref: The genotype is the reference allele\\n * Alt: The genotype is the alternate allele\\n * OtherAlt: The genotype is an unspecified other"," alternate allele. This occurs\\n   in our schema when we have split a multi-allelic genotype into two genotype\\n   records.\\n * NoCall: The genotype could not be called.\",\"symbols\":[\"Ref\",\"Alt\",\"OtherAlt\",\"NoCall\"]}},\"doc\":\"An array describing the genotype called at this site. The length of this\\n   array is equal to the ploidy of the sample at this site. This array may\\n   reference OtherAlt alleles if this site is multi-allelic in this sample.\",\"default\":[]},{\"name\":\"expectedAlleleDosage\",\"type\":[\"null\",\"float\"],\"doc\":\"The expected dosage of the alternate allele in this sample.\",\"default\":null},{\"name\":\"referenceReadDepth\",\"type\":[\"null\",\"int\"],\"doc\":\"The number of reads that show evidence for the reference at this site.\\n\\n   @see alternateReadDepth\\n   @see readDepth\",\"default\":null},{\"name\":\"alternateReadDepth\",\"type\":[\"null\",\"int\"],\"doc\":\"The number of reads that show evidence for this alternate allele at this site.\\n\\n   @see referenceReadDepth\\n   @see readDepth\",\"default\":null},{\"name\":\"readDepth\",\"type\":[\"null\",\"int\"],\"doc\":\"The total number of reads at this site. May not equal (alternateReadDepth +\\n   referenceReadDepth) if this site shows evidence of multiple alternate alleles.\\n\\n   @see referenceReadDepth\\n   @see alternateReadDepth\\n\\n   @note Analogous to VCF's DP.\",\"default\":null},{\"name\":\"minReadDepth\",\"type\":[\"null\",\"int\"],\"doc\":\"The minimum number of reads seen at this site across samples when joint\\n   calling variants.\\n\\n   @note Analogous to VCF's MIN_DP.\",\"default\":null},{\"name\":\"genotypeQuality\",\"type\":[\"null\",\"int\"],\"doc\":\"The phred-scaled probability that we're correct for this genotype call.\\n\\n   @note Analogous to VCF's GQ.\",\"default\":null},{\"name\":\"genotypeLikelihoods\",\"type\":{\"type\":\"array\",\"items\":\"float\"},\"doc\":\"Log scaled likelihoods that we have n copies of this alternate allele.\\n   The number of elements in this array should be equal to the ploidy at this\\n   site, plus 1.\\n\\n   @note Analogous to VCF's PL.\",\"default\":[]},{\"name\":\"nonReferenceLikelihoods\",\"type\":{\"type\":\"array\",\"items\":\"float\"},\"doc\":\"Log scaled likelihoods that we have n non-reference alleles at this site.\\n   The number of elements in this array should be equal to the ploidy at this\\n   site, plus 1.\",\"default\":[]},{\"name\":\"strandBiasComponents\",\"type\":{\"type\":\"array\",\"items\":\"int\"},\"doc\":\"Component statistics which comprise the Fisher's Exact Test to detect strand bias.\\n   If populated, this element should have length 4.\",\"default\":[]},{\"name\":\"splitFromMultiAllelic\",\"type\":[\"boolean\",\"null\"],\"doc\":\"We split multi-allelic VCF lines into multiple\\n   single-alternate records.  This bit is set if that happened for this\\n   record.\",\"default\":false},{\"name\":\"isPhased\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if this genotype is phased.\\n\\n   @see phaseSetId\\n   @see phaseQuality\",\"default\":false},{\"name\":\"phaseSetId\",\"type\":[\"null\",\"int\"],\"doc\":\"The ID of this phase set, if this genotype is phased. Should only be populated\\n   if isPhased == true; else should be null.\\n\\n   @see isPhased\",\"default\":null},{\"name\":\"phaseQuality\",\"type\":[\"null\",\"int\"],\"doc\":\"Phred scaled quality score for the phasing of this genotype, if this genotype\\n   is phased. Should only be populated if isPhased == true; else should be null.\\n\\n   @see isPhased\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The variant called at this site. */
  @Deprecated public org.bdgenomics.formats.avro.Variant variant;
  /** Statistics collected at this site, if available. */
  @Deprecated public org.bdgenomics.formats.avro.VariantCallingAnnotations variantCallingAnnotations;
  /** The unique identifier for this sample. */
  @Deprecated public java.lang.CharSequence sampleId;
  /** A description of this sample. */
  @Deprecated public java.lang.CharSequence sampleDescription;
  /** A string describing the provenance of this sample and the processing applied
   in genotyping this sample. */
  @Deprecated public java.lang.CharSequence processingDescription;
  /** An array describing the genotype called at this site. The length of this
   array is equal to the ploidy of the sample at this site. This array may
   reference OtherAlt alleles if this site is multi-allelic in this sample. */
  @Deprecated public java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> alleles;
  /** The expected dosage of the alternate allele in this sample. */
  @Deprecated public java.lang.Float expectedAlleleDosage;
  /** The number of reads that show evidence for the reference at this site.

   @see alternateReadDepth
   @see readDepth */
  @Deprecated public java.lang.Integer referenceReadDepth;
  /** The number of reads that show evidence for this alternate allele at this site.

   @see referenceReadDepth
   @see readDepth */
  @Deprecated public java.lang.Integer alternateReadDepth;
  /** The total number of reads at this site. May not equal (alternateReadDepth +
   referenceReadDepth) if this site shows evidence of multiple alternate alleles.

   @see referenceReadDepth
   @see alternateReadDepth

   @note Analogous to VCF's DP. */
  @Deprecated public java.lang.Integer readDepth;
  /** The minimum number of reads seen at this site across samples when joint
   calling variants.

   @note Analogous to VCF's MIN_DP. */
  @Deprecated public java.lang.Integer minReadDepth;
  /** The phred-scaled probability that we're correct for this genotype call.

   @note Analogous to VCF's GQ. */
  @Deprecated public java.lang.Integer genotypeQuality;
  /** Log scaled likelihoods that we have n copies of this alternate allele.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1.

   @note Analogous to VCF's PL. */
  @Deprecated public java.util.List<java.lang.Float> genotypeLikelihoods;
  /** Log scaled likelihoods that we have n non-reference alleles at this site.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1. */
  @Deprecated public java.util.List<java.lang.Float> nonReferenceLikelihoods;
  /** Component statistics which comprise the Fisher's Exact Test to detect strand bias.
   If populated, this element should have length 4. */
  @Deprecated public java.util.List<java.lang.Integer> strandBiasComponents;
  /** We split multi-allelic VCF lines into multiple
   single-alternate records.  This bit is set if that happened for this
   record. */
  @Deprecated public java.lang.Boolean splitFromMultiAllelic;
  /** True if this genotype is phased.

   @see phaseSetId
   @see phaseQuality */
  @Deprecated public java.lang.Boolean isPhased;
  /** The ID of this phase set, if this genotype is phased. Should only be populated
   if isPhased == true; else should be null.

   @see isPhased */
  @Deprecated public java.lang.Integer phaseSetId;
  /** Phred scaled quality score for the phasing of this genotype, if this genotype
   is phased. Should only be populated if isPhased == true; else should be null.

   @see isPhased */
  @Deprecated public java.lang.Integer phaseQuality;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public Genotype() {}

  /**
   * All-args constructor.
   */
  public Genotype(org.bdgenomics.formats.avro.Variant variant, org.bdgenomics.formats.avro.VariantCallingAnnotations variantCallingAnnotations, java.lang.CharSequence sampleId, java.lang.CharSequence sampleDescription, java.lang.CharSequence processingDescription, java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> alleles, java.lang.Float expectedAlleleDosage, java.lang.Integer referenceReadDepth, java.lang.Integer alternateReadDepth, java.lang.Integer readDepth, java.lang.Integer minReadDepth, java.lang.Integer genotypeQuality, java.util.List<java.lang.Float> genotypeLikelihoods, java.util.List<java.lang.Float> nonReferenceLikelihoods, java.util.List<java.lang.Integer> strandBiasComponents, java.lang.Boolean splitFromMultiAllelic, java.lang.Boolean isPhased, java.lang.Integer phaseSetId, java.lang.Integer phaseQuality) {
    this.variant = variant;
    this.variantCallingAnnotations = variantCallingAnnotations;
    this.sampleId = sampleId;
    this.sampleDescription = sampleDescription;
    this.processingDescription = processingDescription;
    this.alleles = alleles;
    this.expectedAlleleDosage = expectedAlleleDosage;
    this.referenceReadDepth = referenceReadDepth;
    this.alternateReadDepth = alternateReadDepth;
    this.readDepth = readDepth;
    this.minReadDepth = minReadDepth;
    this.genotypeQuality = genotypeQuality;
    this.genotypeLikelihoods = genotypeLikelihoods;
    this.nonReferenceLikelihoods = nonReferenceLikelihoods;
    this.strandBiasComponents = strandBiasComponents;
    this.splitFromMultiAllelic = splitFromMultiAllelic;
    this.isPhased = isPhased;
    this.phaseSetId = phaseSetId;
    this.phaseQuality = phaseQuality;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return variant;
    case 1: return variantCallingAnnotations;
    case 2: return sampleId;
    case 3: return sampleDescription;
    case 4: return processingDescription;
    case 5: return alleles;
    case 6: return expectedAlleleDosage;
    case 7: return referenceReadDepth;
    case 8: return alternateReadDepth;
    case 9: return readDepth;
    case 10: return minReadDepth;
    case 11: return genotypeQuality;
    case 12: return genotypeLikelihoods;
    case 13: return nonReferenceLikelihoods;
    case 14: return strandBiasComponents;
    case 15: return splitFromMultiAllelic;
    case 16: return isPhased;
    case 17: return phaseSetId;
    case 18: return phaseQuality;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: variant = (org.bdgenomics.formats.avro.Variant)value$; break;
    case 1: variantCallingAnnotations = (org.bdgenomics.formats.avro.VariantCallingAnnotations)value$; break;
    case 2: sampleId = (java.lang.CharSequence)value$; break;
    case 3: sampleDescription = (java.lang.CharSequence)value$; break;
    case 4: processingDescription = (java.lang.CharSequence)value$; break;
    case 5: alleles = (java.util.List<org.bdgenomics.formats.avro.GenotypeAllele>)value$; break;
    case 6: expectedAlleleDosage = (java.lang.Float)value$; break;
    case 7: referenceReadDepth = (java.lang.Integer)value$; break;
    case 8: alternateReadDepth = (java.lang.Integer)value$; break;
    case 9: readDepth = (java.lang.Integer)value$; break;
    case 10: minReadDepth = (java.lang.Integer)value$; break;
    case 11: genotypeQuality = (java.lang.Integer)value$; break;
    case 12: genotypeLikelihoods = (java.util.List<java.lang.Float>)value$; break;
    case 13: nonReferenceLikelihoods = (java.util.List<java.lang.Float>)value$; break;
    case 14: strandBiasComponents = (java.util.List<java.lang.Integer>)value$; break;
    case 15: splitFromMultiAllelic = (java.lang.Boolean)value$; break;
    case 16: isPhased = (java.lang.Boolean)value$; break;
    case 17: phaseSetId = (java.lang.Integer)value$; break;
    case 18: phaseQuality = (java.lang.Integer)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'variant' field.
   * The variant called at this site.   */
  public org.bdgenomics.formats.avro.Variant getVariant() {
    return variant;
  }

  /**
   * Sets the value of the 'variant' field.
   * The variant called at this site.   * @param value the value to set.
   */
  public void setVariant(org.bdgenomics.formats.avro.Variant value) {
    this.variant = value;
  }

  /**
   * Gets the value of the 'variantCallingAnnotations' field.
   * Statistics collected at this site, if available.   */
  public org.bdgenomics.formats.avro.VariantCallingAnnotations getVariantCallingAnnotations() {
    return variantCallingAnnotations;
  }

  /**
   * Sets the value of the 'variantCallingAnnotations' field.
   * Statistics collected at this site, if available.   * @param value the value to set.
   */
  public void setVariantCallingAnnotations(org.bdgenomics.formats.avro.VariantCallingAnnotations value) {
    this.variantCallingAnnotations = value;
  }

  /**
   * Gets the value of the 'sampleId' field.
   * The unique identifier for this sample.   */
  public java.lang.CharSequence getSampleId() {
    return sampleId;
  }

  /**
   * Sets the value of the 'sampleId' field.
   * The unique identifier for this sample.   * @param value the value to set.
   */
  public void setSampleId(java.lang.CharSequence value) {
    this.sampleId = value;
  }

  /**
   * Gets the value of the 'sampleDescription' field.
   * A description of this sample.   */
  public java.lang.CharSequence getSampleDescription() {
    return sampleDescription;
  }

  /**
   * Sets the value of the 'sampleDescription' field.
   * A description of this sample.   * @param value the value to set.
   */
  public void setSampleDescription(java.lang.CharSequence value) {
    this.sampleDescription = value;
  }

  /**
   * Gets the value of the 'processingDescription' field.
   * A string describing the provenance of this sample and the processing applied
   in genotyping this sample.   */
  public java.lang.CharSequence getProcessingDescription() {
    return processingDescription;
  }

  /**
   * Sets the value of the 'processingDescription' field.
   * A string describing the provenance of this sample and the processing applied
   in genotyping this sample.   * @param value the value to set.
   */
  public void setProcessingDescription(java.lang.CharSequence value) {
    this.processingDescription = value;
  }

  /**
   * Gets the value of the 'alleles' field.
   * An array describing the genotype called at this site. The length of this
   array is equal to the ploidy of the sample at this site. This array may
   reference OtherAlt alleles if this site is multi-allelic in this sample.   */
  public java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> getAlleles() {
    return alleles;
  }

  /**
   * Sets the value of the 'alleles' field.
   * An array describing the genotype called at this site. The length of this
   array is equal to the ploidy of the sample at this site. This array may
   reference OtherAlt alleles if this site is multi-allelic in this sample.   * @param value the value to set.
   */
  public void setAlleles(java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> value) {
    this.alleles = value;
  }

  /**
   * Gets the value of the 'expectedAlleleDosage' field.
   * The expected dosage of the alternate allele in this sample.   */
  public java.lang.Float getExpectedAlleleDosage() {
    return expectedAlleleDosage;
  }

  /**
   * Sets the value of the 'expectedAlleleDosage' field.
   * The expected dosage of the alternate allele in this sample.   * @param value the value to set.
   */
  public void setExpectedAlleleDosage(java.lang.Float value) {
    this.expectedAlleleDosage = value;
  }

  /**
   * Gets the value of the 'referenceReadDepth' field.
   * The number of reads that show evidence for the reference at this site.

   @see alternateReadDepth
   @see readDepth   */
  public java.lang.Integer getReferenceReadDepth() {
    return referenceReadDepth;
  }

  /**
   * Sets the value of the 'referenceReadDepth' field.
   * The number of reads that show evidence for the reference at this site.

   @see alternateReadDepth
   @see readDepth   * @param value the value to set.
   */
  public void setReferenceReadDepth(java.lang.Integer value) {
    this.referenceReadDepth = value;
  }

  /**
   * Gets the value of the 'alternateReadDepth' field.
   * The number of reads that show evidence for this alternate allele at this site.

   @see referenceReadDepth
   @see readDepth   */
  public java.lang.Integer getAlternateReadDepth() {
    return alternateReadDepth;
  }

  /**
   * Sets the value of the 'alternateReadDepth' field.
   * The number of reads that show evidence for this alternate allele at this site.

   @see referenceReadDepth
   @see readDepth   * @param value the value to set.
   */
  public void setAlternateReadDepth(java.lang.Integer value) {
    this.alternateReadDepth = value;
  }

  /**
   * Gets the value of the 'readDepth' field.
   * The total number of reads at this site. May not equal (alternateReadDepth +
   referenceReadDepth) if this site shows evidence of multiple alternate alleles.

   @see referenceReadDepth
   @see alternateReadDepth

   @note Analogous to VCF's DP.   */
  public java.lang.Integer getReadDepth() {
    return readDepth;
  }

  /**
   * Sets the value of the 'readDepth' field.
   * The total number of reads at this site. May not equal (alternateReadDepth +
   referenceReadDepth) if this site shows evidence of multiple alternate alleles.

   @see referenceReadDepth
   @see alternateReadDepth

   @note Analogous to VCF's DP.   * @param value the value to set.
   */
  public void setReadDepth(java.lang.Integer value) {
    this.readDepth = value;
  }

  /**
   * Gets the value of the 'minReadDepth' field.
   * The minimum number of reads seen at this site across samples when joint
   calling variants.

   @note Analogous to VCF's MIN_DP.   */
  public java.lang.Integer getMinReadDepth() {
    return minReadDepth;
  }

  /**
   * Sets the value of the 'minReadDepth' field.
   * The minimum number of reads seen at this site across samples when joint
   calling variants.

   @note Analogous to VCF's MIN_DP.   * @param value the value to set.
   */
  public void setMinReadDepth(java.lang.Integer value) {
    this.minReadDepth = value;
  }

  /**
   * Gets the value of the 'genotypeQuality' field.
   * The phred-scaled probability that we're correct for this genotype call.

   @note Analogous to VCF's GQ.   */
  public java.lang.Integer getGenotypeQuality() {
    return genotypeQuality;
  }

  /**
   * Sets the value of the 'genotypeQuality' field.
   * The phred-scaled probability that we're correct for this genotype call.

   @note Analogous to VCF's GQ.   * @param value the value to set.
   */
  public void setGenotypeQuality(java.lang.Integer value) {
    this.genotypeQuality = value;
  }

  /**
   * Gets the value of the 'genotypeLikelihoods' field.
   * Log scaled likelihoods that we have n copies of this alternate allele.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1.

   @note Analogous to VCF's PL.   */
  public java.util.List<java.lang.Float> getGenotypeLikelihoods() {
    return genotypeLikelihoods;
  }

  /**
   * Sets the value of the 'genotypeLikelihoods' field.
   * Log scaled likelihoods that we have n copies of this alternate allele.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1.

   @note Analogous to VCF's PL.   * @param value the value to set.
   */
  public void setGenotypeLikelihoods(java.util.List<java.lang.Float> value) {
    this.genotypeLikelihoods = value;
  }

  /**
   * Gets the value of the 'nonReferenceLikelihoods' field.
   * Log scaled likelihoods that we have n non-reference alleles at this site.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1.   */
  public java.util.List<java.lang.Float> getNonReferenceLikelihoods() {
    return nonReferenceLikelihoods;
  }

  /**
   * Sets the value of the 'nonReferenceLikelihoods' field.
   * Log scaled likelihoods that we have n non-reference alleles at this site.
   The number of elements in this array should be equal to the ploidy at this
   site, plus 1.   * @param value the value to set.
   */
  public void setNonReferenceLikelihoods(java.util.List<java.lang.Float> value) {
    this.nonReferenceLikelihoods = value;
  }

  /**
   * Gets the value of the 'strandBiasComponents' field.
   * Component statistics which comprise the Fisher's Exact Test to detect strand bias.
   If populated, this element should have length 4.   */
  public java.util.List<java.lang.Integer> getStrandBiasComponents() {
    return strandBiasComponents;
  }

  /**
   * Sets the value of the 'strandBiasComponents' field.
   * Component statistics which comprise the Fisher's Exact Test to detect strand bias.
   If populated, this element should have length 4.   * @param value the value to set.
   */
  public void setStrandBiasComponents(java.util.List<java.lang.Integer> value) {
    this.strandBiasComponents = value;
  }

  /**
   * Gets the value of the 'splitFromMultiAllelic' field.
   * We split multi-allelic VCF lines into multiple
   single-alternate records.  This bit is set if that happened for this
   record.   */
  public java.lang.Boolean getSplitFromMultiAllelic() {
    return splitFromMultiAllelic;
  }

  /**
   * Sets the value of the 'splitFromMultiAllelic' field.
   * We split multi-allelic VCF lines into multiple
   single-alternate records.  This bit is set if that happened for this
   record.   * @param value the value to set.
   */
  public void setSplitFromMultiAllelic(java.lang.Boolean value) {
    this.splitFromMultiAllelic = value;
  }

  /**
   * Gets the value of the 'isPhased' field.
   * True if this genotype is phased.

   @see phaseSetId
   @see phaseQuality   */
  public java.lang.Boolean getIsPhased() {
    return isPhased;
  }

  /**
   * Sets the value of the 'isPhased' field.
   * True if this genotype is phased.

   @see phaseSetId
   @see phaseQuality   * @param value the value to set.
   */
  public void setIsPhased(java.lang.Boolean value) {
    this.isPhased = value;
  }

  /**
   * Gets the value of the 'phaseSetId' field.
   * The ID of this phase set, if this genotype is phased. Should only be populated
   if isPhased == true; else should be null.

   @see isPhased   */
  public java.lang.Integer getPhaseSetId() {
    return phaseSetId;
  }

  /**
   * Sets the value of the 'phaseSetId' field.
   * The ID of this phase set, if this genotype is phased. Should only be populated
   if isPhased == true; else should be null.

   @see isPhased   * @param value the value to set.
   */
  public void setPhaseSetId(java.lang.Integer value) {
    this.phaseSetId = value;
  }

  /**
   * Gets the value of the 'phaseQuality' field.
   * Phred scaled quality score for the phasing of this genotype, if this genotype
   is phased. Should only be populated if isPhased == true; else should be null.

   @see isPhased   */
  public java.lang.Integer getPhaseQuality() {
    return phaseQuality;
  }

  /**
   * Sets the value of the 'phaseQuality' field.
   * Phred scaled quality score for the phasing of this genotype, if this genotype
   is phased. Should only be populated if isPhased == true; else should be null.

   @see isPhased   * @param value the value to set.
   */
  public void setPhaseQuality(java.lang.Integer value) {
    this.phaseQuality = value;
  }

  /** Creates a new Genotype RecordBuilder */
  public static org.bdgenomics.formats.avro.Genotype.Builder newBuilder() {
    return new org.bdgenomics.formats.avro.Genotype.Builder();
  }
  
  /** Creates a new Genotype RecordBuilder by copying an existing Builder */
  public static org.bdgenomics.formats.avro.Genotype.Builder newBuilder(org.bdgenomics.formats.avro.Genotype.Builder other) {
    return new org.bdgenomics.formats.avro.Genotype.Builder(other);
  }
  
  /** Creates a new Genotype RecordBuilder by copying an existing Genotype instance */
  public static org.bdgenomics.formats.avro.Genotype.Builder newBuilder(org.bdgenomics.formats.avro.Genotype other) {
    return new org.bdgenomics.formats.avro.Genotype.Builder(other);
  }
  
  /**
   * RecordBuilder for Genotype instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<Genotype>
    implements org.apache.avro.data.RecordBuilder<Genotype> {

    private org.bdgenomics.formats.avro.Variant variant;
    private org.bdgenomics.formats.avro.VariantCallingAnnotations variantCallingAnnotations;
    private java.lang.CharSequence sampleId;
    private java.lang.CharSequence sampleDescription;
    private java.lang.CharSequence processingDescription;
    private java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> alleles;
    private java.lang.Float expectedAlleleDosage;
    private java.lang.Integer referenceReadDepth;
    private java.lang.Integer alternateReadDepth;
    private java.lang.Integer readDepth;
    private java.lang.Integer minReadDepth;
    private java.lang.Integer genotypeQuality;
    private java.util.List<java.lang.Float> genotypeLikelihoods;
    private java.util.List<java.lang.Float> nonReferenceLikelihoods;
    private java.util.List<java.lang.Integer> strandBiasComponents;
    private java.lang.Boolean splitFromMultiAllelic;
    private java.lang.Boolean isPhased;
    private java.lang.Integer phaseSetId;
    private java.lang.Integer phaseQuality;

    /** Creates a new Builder */
    private Builder() {
      super(org.bdgenomics.formats.avro.Genotype.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.bdgenomics.formats.avro.Genotype.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.variant)) {
        this.variant = data().deepCopy(fields()[0].schema(), other.variant);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.variantCallingAnnotations)) {
        this.variantCallingAnnotations = data().deepCopy(fields()[1].schema(), other.variantCallingAnnotations);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.sampleId)) {
        this.sampleId = data().deepCopy(fields()[2].schema(), other.sampleId);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.sampleDescription)) {
        this.sampleDescription = data().deepCopy(fields()[3].schema(), other.sampleDescription);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.processingDescription)) {
        this.processingDescription = data().deepCopy(fields()[4].schema(), other.processingDescription);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.alleles)) {
        this.alleles = data().deepCopy(fields()[5].schema(), other.alleles);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.expectedAlleleDosage)) {
        this.expectedAlleleDosage = data().deepCopy(fields()[6].schema(), other.expectedAlleleDosage);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.referenceReadDepth)) {
        this.referenceReadDepth = data().deepCopy(fields()[7].schema(), other.referenceReadDepth);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.alternateReadDepth)) {
        this.alternateReadDepth = data().deepCopy(fields()[8].schema(), other.alternateReadDepth);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.readDepth)) {
        this.readDepth = data().deepCopy(fields()[9].schema(), other.readDepth);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.minReadDepth)) {
        this.minReadDepth = data().deepCopy(fields()[10].schema(), other.minReadDepth);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.genotypeQuality)) {
        this.genotypeQuality = data().deepCopy(fields()[11].schema(), other.genotypeQuality);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.genotypeLikelihoods)) {
        this.genotypeLikelihoods = data().deepCopy(fields()[12].schema(), other.genotypeLikelihoods);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.nonReferenceLikelihoods)) {
        this.nonReferenceLikelihoods = data().deepCopy(fields()[13].schema(), other.nonReferenceLikelihoods);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.strandBiasComponents)) {
        this.strandBiasComponents = data().deepCopy(fields()[14].schema(), other.strandBiasComponents);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.splitFromMultiAllelic)) {
        this.splitFromMultiAllelic = data().deepCopy(fields()[15].schema(), other.splitFromMultiAllelic);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.isPhased)) {
        this.isPhased = data().deepCopy(fields()[16].schema(), other.isPhased);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.phaseSetId)) {
        this.phaseSetId = data().deepCopy(fields()[17].schema(), other.phaseSetId);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.phaseQuality)) {
        this.phaseQuality = data().deepCopy(fields()[18].schema(), other.phaseQuality);
        fieldSetFlags()[18] = true;
      }
    }
    
    /** Creates a Builder by copying an existing Genotype instance */
    private Builder(org.bdgenomics.formats.avro.Genotype other) {
            super(org.bdgenomics.formats.avro.Genotype.SCHEMA$);
      if (isValidValue(fields()[0], other.variant)) {
        this.variant = data().deepCopy(fields()[0].schema(), other.variant);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.variantCallingAnnotations)) {
        this.variantCallingAnnotations = data().deepCopy(fields()[1].schema(), other.variantCallingAnnotations);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.sampleId)) {
        this.sampleId = data().deepCopy(fields()[2].schema(), other.sampleId);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.sampleDescription)) {
        this.sampleDescription = data().deepCopy(fields()[3].schema(), other.sampleDescription);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.processingDescription)) {
        this.processingDescription = data().deepCopy(fields()[4].schema(), other.processingDescription);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.alleles)) {
        this.alleles = data().deepCopy(fields()[5].schema(), other.alleles);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.expectedAlleleDosage)) {
        this.expectedAlleleDosage = data().deepCopy(fields()[6].schema(), other.expectedAlleleDosage);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.referenceReadDepth)) {
        this.referenceReadDepth = data().deepCopy(fields()[7].schema(), other.referenceReadDepth);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.alternateReadDepth)) {
        this.alternateReadDepth = data().deepCopy(fields()[8].schema(), other.alternateReadDepth);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.readDepth)) {
        this.readDepth = data().deepCopy(fields()[9].schema(), other.readDepth);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.minReadDepth)) {
        this.minReadDepth = data().deepCopy(fields()[10].schema(), other.minReadDepth);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.genotypeQuality)) {
        this.genotypeQuality = data().deepCopy(fields()[11].schema(), other.genotypeQuality);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.genotypeLikelihoods)) {
        this.genotypeLikelihoods = data().deepCopy(fields()[12].schema(), other.genotypeLikelihoods);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.nonReferenceLikelihoods)) {
        this.nonReferenceLikelihoods = data().deepCopy(fields()[13].schema(), other.nonReferenceLikelihoods);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.strandBiasComponents)) {
        this.strandBiasComponents = data().deepCopy(fields()[14].schema(), other.strandBiasComponents);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.splitFromMultiAllelic)) {
        this.splitFromMultiAllelic = data().deepCopy(fields()[15].schema(), other.splitFromMultiAllelic);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.isPhased)) {
        this.isPhased = data().deepCopy(fields()[16].schema(), other.isPhased);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.phaseSetId)) {
        this.phaseSetId = data().deepCopy(fields()[17].schema(), other.phaseSetId);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.phaseQuality)) {
        this.phaseQuality = data().deepCopy(fields()[18].schema(), other.phaseQuality);
        fieldSetFlags()[18] = true;
      }
    }

    /** Gets the value of the 'variant' field */
    public org.bdgenomics.formats.avro.Variant getVariant() {
      return variant;
    }
    
    /** Sets the value of the 'variant' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setVariant(org.bdgenomics.formats.avro.Variant value) {
      validate(fields()[0], value);
      this.variant = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'variant' field has been set */
    public boolean hasVariant() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'variant' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearVariant() {
      variant = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'variantCallingAnnotations' field */
    public org.bdgenomics.formats.avro.VariantCallingAnnotations getVariantCallingAnnotations() {
      return variantCallingAnnotations;
    }
    
    /** Sets the value of the 'variantCallingAnnotations' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setVariantCallingAnnotations(org.bdgenomics.formats.avro.VariantCallingAnnotations value) {
      validate(fields()[1], value);
      this.variantCallingAnnotations = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'variantCallingAnnotations' field has been set */
    public boolean hasVariantCallingAnnotations() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'variantCallingAnnotations' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearVariantCallingAnnotations() {
      variantCallingAnnotations = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'sampleId' field */
    public java.lang.CharSequence getSampleId() {
      return sampleId;
    }
    
    /** Sets the value of the 'sampleId' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setSampleId(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.sampleId = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'sampleId' field has been set */
    public boolean hasSampleId() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'sampleId' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearSampleId() {
      sampleId = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'sampleDescription' field */
    public java.lang.CharSequence getSampleDescription() {
      return sampleDescription;
    }
    
    /** Sets the value of the 'sampleDescription' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setSampleDescription(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.sampleDescription = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'sampleDescription' field has been set */
    public boolean hasSampleDescription() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'sampleDescription' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearSampleDescription() {
      sampleDescription = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'processingDescription' field */
    public java.lang.CharSequence getProcessingDescription() {
      return processingDescription;
    }
    
    /** Sets the value of the 'processingDescription' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setProcessingDescription(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.processingDescription = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'processingDescription' field has been set */
    public boolean hasProcessingDescription() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'processingDescription' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearProcessingDescription() {
      processingDescription = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'alleles' field */
    public java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> getAlleles() {
      return alleles;
    }
    
    /** Sets the value of the 'alleles' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setAlleles(java.util.List<org.bdgenomics.formats.avro.GenotypeAllele> value) {
      validate(fields()[5], value);
      this.alleles = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'alleles' field has been set */
    public boolean hasAlleles() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'alleles' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearAlleles() {
      alleles = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'expectedAlleleDosage' field */
    public java.lang.Float getExpectedAlleleDosage() {
      return expectedAlleleDosage;
    }
    
    /** Sets the value of the 'expectedAlleleDosage' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setExpectedAlleleDosage(java.lang.Float value) {
      validate(fields()[6], value);
      this.expectedAlleleDosage = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'expectedAlleleDosage' field has been set */
    public boolean hasExpectedAlleleDosage() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'expectedAlleleDosage' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearExpectedAlleleDosage() {
      expectedAlleleDosage = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'referenceReadDepth' field */
    public java.lang.Integer getReferenceReadDepth() {
      return referenceReadDepth;
    }
    
    /** Sets the value of the 'referenceReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setReferenceReadDepth(java.lang.Integer value) {
      validate(fields()[7], value);
      this.referenceReadDepth = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'referenceReadDepth' field has been set */
    public boolean hasReferenceReadDepth() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'referenceReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearReferenceReadDepth() {
      referenceReadDepth = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'alternateReadDepth' field */
    public java.lang.Integer getAlternateReadDepth() {
      return alternateReadDepth;
    }
    
    /** Sets the value of the 'alternateReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setAlternateReadDepth(java.lang.Integer value) {
      validate(fields()[8], value);
      this.alternateReadDepth = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'alternateReadDepth' field has been set */
    public boolean hasAlternateReadDepth() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'alternateReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearAlternateReadDepth() {
      alternateReadDepth = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'readDepth' field */
    public java.lang.Integer getReadDepth() {
      return readDepth;
    }
    
    /** Sets the value of the 'readDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setReadDepth(java.lang.Integer value) {
      validate(fields()[9], value);
      this.readDepth = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'readDepth' field has been set */
    public boolean hasReadDepth() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'readDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearReadDepth() {
      readDepth = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'minReadDepth' field */
    public java.lang.Integer getMinReadDepth() {
      return minReadDepth;
    }
    
    /** Sets the value of the 'minReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setMinReadDepth(java.lang.Integer value) {
      validate(fields()[10], value);
      this.minReadDepth = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'minReadDepth' field has been set */
    public boolean hasMinReadDepth() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'minReadDepth' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearMinReadDepth() {
      minReadDepth = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'genotypeQuality' field */
    public java.lang.Integer getGenotypeQuality() {
      return genotypeQuality;
    }
    
    /** Sets the value of the 'genotypeQuality' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setGenotypeQuality(java.lang.Integer value) {
      validate(fields()[11], value);
      this.genotypeQuality = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'genotypeQuality' field has been set */
    public boolean hasGenotypeQuality() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'genotypeQuality' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearGenotypeQuality() {
      genotypeQuality = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'genotypeLikelihoods' field */
    public java.util.List<java.lang.Float> getGenotypeLikelihoods() {
      return genotypeLikelihoods;
    }
    
    /** Sets the value of the 'genotypeLikelihoods' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setGenotypeLikelihoods(java.util.List<java.lang.Float> value) {
      validate(fields()[12], value);
      this.genotypeLikelihoods = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'genotypeLikelihoods' field has been set */
    public boolean hasGenotypeLikelihoods() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'genotypeLikelihoods' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearGenotypeLikelihoods() {
      genotypeLikelihoods = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'nonReferenceLikelihoods' field */
    public java.util.List<java.lang.Float> getNonReferenceLikelihoods() {
      return nonReferenceLikelihoods;
    }
    
    /** Sets the value of the 'nonReferenceLikelihoods' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setNonReferenceLikelihoods(java.util.List<java.lang.Float> value) {
      validate(fields()[13], value);
      this.nonReferenceLikelihoods = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'nonReferenceLikelihoods' field has been set */
    public boolean hasNonReferenceLikelihoods() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'nonReferenceLikelihoods' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearNonReferenceLikelihoods() {
      nonReferenceLikelihoods = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'strandBiasComponents' field */
    public java.util.List<java.lang.Integer> getStrandBiasComponents() {
      return strandBiasComponents;
    }
    
    /** Sets the value of the 'strandBiasComponents' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setStrandBiasComponents(java.util.List<java.lang.Integer> value) {
      validate(fields()[14], value);
      this.strandBiasComponents = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'strandBiasComponents' field has been set */
    public boolean hasStrandBiasComponents() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'strandBiasComponents' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearStrandBiasComponents() {
      strandBiasComponents = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'splitFromMultiAllelic' field */
    public java.lang.Boolean getSplitFromMultiAllelic() {
      return splitFromMultiAllelic;
    }
    
    /** Sets the value of the 'splitFromMultiAllelic' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setSplitFromMultiAllelic(java.lang.Boolean value) {
      validate(fields()[15], value);
      this.splitFromMultiAllelic = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'splitFromMultiAllelic' field has been set */
    public boolean hasSplitFromMultiAllelic() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'splitFromMultiAllelic' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearSplitFromMultiAllelic() {
      splitFromMultiAllelic = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    /** Gets the value of the 'isPhased' field */
    public java.lang.Boolean getIsPhased() {
      return isPhased;
    }
    
    /** Sets the value of the 'isPhased' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setIsPhased(java.lang.Boolean value) {
      validate(fields()[16], value);
      this.isPhased = value;
      fieldSetFlags()[16] = true;
      return this; 
    }
    
    /** Checks whether the 'isPhased' field has been set */
    public boolean hasIsPhased() {
      return fieldSetFlags()[16];
    }
    
    /** Clears the value of the 'isPhased' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearIsPhased() {
      isPhased = null;
      fieldSetFlags()[16] = false;
      return this;
    }

    /** Gets the value of the 'phaseSetId' field */
    public java.lang.Integer getPhaseSetId() {
      return phaseSetId;
    }
    
    /** Sets the value of the 'phaseSetId' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setPhaseSetId(java.lang.Integer value) {
      validate(fields()[17], value);
      this.phaseSetId = value;
      fieldSetFlags()[17] = true;
      return this; 
    }
    
    /** Checks whether the 'phaseSetId' field has been set */
    public boolean hasPhaseSetId() {
      return fieldSetFlags()[17];
    }
    
    /** Clears the value of the 'phaseSetId' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearPhaseSetId() {
      phaseSetId = null;
      fieldSetFlags()[17] = false;
      return this;
    }

    /** Gets the value of the 'phaseQuality' field */
    public java.lang.Integer getPhaseQuality() {
      return phaseQuality;
    }
    
    /** Sets the value of the 'phaseQuality' field */
    public org.bdgenomics.formats.avro.Genotype.Builder setPhaseQuality(java.lang.Integer value) {
      validate(fields()[18], value);
      this.phaseQuality = value;
      fieldSetFlags()[18] = true;
      return this; 
    }
    
    /** Checks whether the 'phaseQuality' field has been set */
    public boolean hasPhaseQuality() {
      return fieldSetFlags()[18];
    }
    
    /** Clears the value of the 'phaseQuality' field */
    public org.bdgenomics.formats.avro.Genotype.Builder clearPhaseQuality() {
      phaseQuality = null;
      fieldSetFlags()[18] = false;
      return this;
    }

    @Override
    public Genotype build() {
      try {
        Genotype record = new Genotype();
        record.variant = fieldSetFlags()[0] ? this.variant : (org.bdgenomics.formats.avro.Variant) defaultValue(fields()[0]);
        record.variantCallingAnnotations = fieldSetFlags()[1] ? this.variantCallingAnnotations : (org.bdgenomics.formats.avro.VariantCallingAnnotations) defaultValue(fields()[1]);
        record.sampleId = fieldSetFlags()[2] ? this.sampleId : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.sampleDescription = fieldSetFlags()[3] ? this.sampleDescription : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.processingDescription = fieldSetFlags()[4] ? this.processingDescription : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.alleles = fieldSetFlags()[5] ? this.alleles : (java.util.List<org.bdgenomics.formats.avro.GenotypeAllele>) defaultValue(fields()[5]);
        record.expectedAlleleDosage = fieldSetFlags()[6] ? this.expectedAlleleDosage : (java.lang.Float) defaultValue(fields()[6]);
        record.referenceReadDepth = fieldSetFlags()[7] ? this.referenceReadDepth : (java.lang.Integer) defaultValue(fields()[7]);
        record.alternateReadDepth = fieldSetFlags()[8] ? this.alternateReadDepth : (java.lang.Integer) defaultValue(fields()[8]);
        record.readDepth = fieldSetFlags()[9] ? this.readDepth : (java.lang.Integer) defaultValue(fields()[9]);
        record.minReadDepth = fieldSetFlags()[10] ? this.minReadDepth : (java.lang.Integer) defaultValue(fields()[10]);
        record.genotypeQuality = fieldSetFlags()[11] ? this.genotypeQuality : (java.lang.Integer) defaultValue(fields()[11]);
        record.genotypeLikelihoods = fieldSetFlags()[12] ? this.genotypeLikelihoods : (java.util.List<java.lang.Float>) defaultValue(fields()[12]);
        record.nonReferenceLikelihoods = fieldSetFlags()[13] ? this.nonReferenceLikelihoods : (java.util.List<java.lang.Float>) defaultValue(fields()[13]);
        record.strandBiasComponents = fieldSetFlags()[14] ? this.strandBiasComponents : (java.util.List<java.lang.Integer>) defaultValue(fields()[14]);
        record.splitFromMultiAllelic = fieldSetFlags()[15] ? this.splitFromMultiAllelic : (java.lang.Boolean) defaultValue(fields()[15]);
        record.isPhased = fieldSetFlags()[16] ? this.isPhased : (java.lang.Boolean) defaultValue(fields()[16]);
        record.phaseSetId = fieldSetFlags()[17] ? this.phaseSetId : (java.lang.Integer) defaultValue(fields()[17]);
        record.phaseQuality = fieldSetFlags()[18] ? this.phaseQuality : (java.lang.Integer) defaultValue(fields()[18]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
