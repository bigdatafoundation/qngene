/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bdgenomics.formats.avro;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class Variant extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Variant\",\"namespace\":\"org.bdgenomics.formats.avro\",\"fields\":[{\"name\":\"variantErrorProbability\",\"type\":[\"null\",\"int\"],\"doc\":\"The Phred scaled error probability of a variant, given the probabilities of\\n   the variant in a population.\",\"default\":null},{\"name\":\"contig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Contig\",\"doc\":\"Record for describing a reference assembly. Not used for storing the contents\\n of said assembly.\\n\\n @see NucleotideContigFragment\",\"fields\":[{\"name\":\"contigName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this contig in the assembly (e.g., \\\"chr1\\\").\",\"default\":null},{\"name\":\"contigLength\",\"type\":[\"null\",\"long\"],\"doc\":\"The length of this contig.\",\"default\":null},{\"name\":\"contigMD5\",\"type\":[\"null\",\"string\"],\"doc\":\"The MD5 checksum of the assembly for this contig.\",\"default\":null},{\"name\":\"referenceURL\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL at which this reference assembly can be found.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this assembly (e.g., \\\"hg19\\\").\",\"default\":null},{\"name\":\"species\",\"type\":[\"null\",\"string\"],\"doc\":\"The species that this assembly is for.\",\"default\":null},{\"name\":\"referenceIndex\",\"type\":[\"null\",\"int\"],\"doc\":\"Optional 0-based index of this contig in a SAM file header that it was read\\n   from; helps output SAMs/BAMs with headers in the same order as they started\\n   with, before a conversion to ADAM.\",\"default\":null}]}],\"doc\":\"The reference contig that this variant exists on.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"The 0-based start position of this variant on the reference contig.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"The 0-based, exclusive end position of this variant on the reference contig.\",\"default\":null},{\"name\":\"referenceAllele\",\"type\":[\"null\",\"string\"],\"doc\":\"A string describing the reference allele at this site.\",\"default\":null},{\"name\":\"alternateAllele\",\"type\":[\"null\",\"string\"],\"doc\":\"A string describing the variant allele at this site. Should be left null if\\n   the site is a structural variant.\",\"default\":null},{\"name\":\"svAllele\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"StructuralVariant\",\"fields\":[{\"name\":\"type\",\"type\":[\"null\",{\"type\":\"enum\",\"name\":\"StructuralVariantType\",\"doc\":\"Descriptors for the type of a structural variant. The most specific descriptor\\n should be used, if possible. E.g., duplication should be used instead of\\n insertion if the inserted sequence is not novel. Tandem duplication should\\n be used instead of duplication if the duplication is known to follow the\\n duplicated sequence.\",\"symbols\":[\"DELETION\",\"INSERTION\",\"INVERSION\",\"MOBILE_INSERTION\",\"MOBILE_DELETION\",\"DUPLICATION\",\"TANDEM_DUPLICATION\"]}],\"doc\":\"The type of this structural variant.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL of the FASTA/NucleotideContig assembly for this structural variant,\\n   if one is available.\",\"default\":null},{\"name\":\"precise\",\"type\":[\"boolean\",\"null\"],\"doc\":\"Whether this structural variant call has precise breakpoints or not. Default\\n   value is true. If the call is imprecise, confidence intervals should be provided.\",\"default\":true},{\"name\":\"startWindow\",\"type\":[\"null\",\"int\"],\"doc\":\"The size of the confidence window around the start of the structural variant.\",\"default\":null},{\"name\":\"endWindow\",\"type\":[\"null\",\"int\"],\"doc\":\"The size of the confidence window around the end of the structural variant.\",\"default\":null}]}],\"doc\":\"The structural variant at this site, if the alternate allele is a structural\\n   variant. If the site is not a structural variant, this field should be left\\n   null.\",\"default\":null},{\"name\":\"isSomatic\",\"type\":[\"boolean\",\"null\"],\"doc\":\"A boolean describing whether this variant call is somatic; in this case, the\\n   `referenceAllele` will have been observed in another sample.\",\"default\":false}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The Phred scaled error probability of a variant, given the probabilities of
   the variant in a population. */
  @Deprecated public java.lang.Integer variantErrorProbability;
  /** The reference contig that this variant exists on. */
  @Deprecated public org.bdgenomics.formats.avro.Contig contig;
  /** The 0-based start position of this variant on the reference contig. */
  @Deprecated public java.lang.Long start;
  /** The 0-based, exclusive end position of this variant on the reference contig. */
  @Deprecated public java.lang.Long end;
  /** A string describing the reference allele at this site. */
  @Deprecated public java.lang.CharSequence referenceAllele;
  /** A string describing the variant allele at this site. Should be left null if
   the site is a structural variant. */
  @Deprecated public java.lang.CharSequence alternateAllele;
  /** The structural variant at this site, if the alternate allele is a structural
   variant. If the site is not a structural variant, this field should be left
   null. */
  @Deprecated public org.bdgenomics.formats.avro.StructuralVariant svAllele;
  /** A boolean describing whether this variant call is somatic; in this case, the
   `referenceAllele` will have been observed in another sample. */
  @Deprecated public java.lang.Boolean isSomatic;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public Variant() {}

  /**
   * All-args constructor.
   */
  public Variant(java.lang.Integer variantErrorProbability, org.bdgenomics.formats.avro.Contig contig, java.lang.Long start, java.lang.Long end, java.lang.CharSequence referenceAllele, java.lang.CharSequence alternateAllele, org.bdgenomics.formats.avro.StructuralVariant svAllele, java.lang.Boolean isSomatic) {
    this.variantErrorProbability = variantErrorProbability;
    this.contig = contig;
    this.start = start;
    this.end = end;
    this.referenceAllele = referenceAllele;
    this.alternateAllele = alternateAllele;
    this.svAllele = svAllele;
    this.isSomatic = isSomatic;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return variantErrorProbability;
    case 1: return contig;
    case 2: return start;
    case 3: return end;
    case 4: return referenceAllele;
    case 5: return alternateAllele;
    case 6: return svAllele;
    case 7: return isSomatic;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: variantErrorProbability = (java.lang.Integer)value$; break;
    case 1: contig = (org.bdgenomics.formats.avro.Contig)value$; break;
    case 2: start = (java.lang.Long)value$; break;
    case 3: end = (java.lang.Long)value$; break;
    case 4: referenceAllele = (java.lang.CharSequence)value$; break;
    case 5: alternateAllele = (java.lang.CharSequence)value$; break;
    case 6: svAllele = (org.bdgenomics.formats.avro.StructuralVariant)value$; break;
    case 7: isSomatic = (java.lang.Boolean)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'variantErrorProbability' field.
   * The Phred scaled error probability of a variant, given the probabilities of
   the variant in a population.   */
  public java.lang.Integer getVariantErrorProbability() {
    return variantErrorProbability;
  }

  /**
   * Sets the value of the 'variantErrorProbability' field.
   * The Phred scaled error probability of a variant, given the probabilities of
   the variant in a population.   * @param value the value to set.
   */
  public void setVariantErrorProbability(java.lang.Integer value) {
    this.variantErrorProbability = value;
  }

  /**
   * Gets the value of the 'contig' field.
   * The reference contig that this variant exists on.   */
  public org.bdgenomics.formats.avro.Contig getContig() {
    return contig;
  }

  /**
   * Sets the value of the 'contig' field.
   * The reference contig that this variant exists on.   * @param value the value to set.
   */
  public void setContig(org.bdgenomics.formats.avro.Contig value) {
    this.contig = value;
  }

  /**
   * Gets the value of the 'start' field.
   * The 0-based start position of this variant on the reference contig.   */
  public java.lang.Long getStart() {
    return start;
  }

  /**
   * Sets the value of the 'start' field.
   * The 0-based start position of this variant on the reference contig.   * @param value the value to set.
   */
  public void setStart(java.lang.Long value) {
    this.start = value;
  }

  /**
   * Gets the value of the 'end' field.
   * The 0-based, exclusive end position of this variant on the reference contig.   */
  public java.lang.Long getEnd() {
    return end;
  }

  /**
   * Sets the value of the 'end' field.
   * The 0-based, exclusive end position of this variant on the reference contig.   * @param value the value to set.
   */
  public void setEnd(java.lang.Long value) {
    this.end = value;
  }

  /**
   * Gets the value of the 'referenceAllele' field.
   * A string describing the reference allele at this site.   */
  public java.lang.CharSequence getReferenceAllele() {
    return referenceAllele;
  }

  /**
   * Sets the value of the 'referenceAllele' field.
   * A string describing the reference allele at this site.   * @param value the value to set.
   */
  public void setReferenceAllele(java.lang.CharSequence value) {
    this.referenceAllele = value;
  }

  /**
   * Gets the value of the 'alternateAllele' field.
   * A string describing the variant allele at this site. Should be left null if
   the site is a structural variant.   */
  public java.lang.CharSequence getAlternateAllele() {
    return alternateAllele;
  }

  /**
   * Sets the value of the 'alternateAllele' field.
   * A string describing the variant allele at this site. Should be left null if
   the site is a structural variant.   * @param value the value to set.
   */
  public void setAlternateAllele(java.lang.CharSequence value) {
    this.alternateAllele = value;
  }

  /**
   * Gets the value of the 'svAllele' field.
   * The structural variant at this site, if the alternate allele is a structural
   variant. If the site is not a structural variant, this field should be left
   null.   */
  public org.bdgenomics.formats.avro.StructuralVariant getSvAllele() {
    return svAllele;
  }

  /**
   * Sets the value of the 'svAllele' field.
   * The structural variant at this site, if the alternate allele is a structural
   variant. If the site is not a structural variant, this field should be left
   null.   * @param value the value to set.
   */
  public void setSvAllele(org.bdgenomics.formats.avro.StructuralVariant value) {
    this.svAllele = value;
  }

  /**
   * Gets the value of the 'isSomatic' field.
   * A boolean describing whether this variant call is somatic; in this case, the
   `referenceAllele` will have been observed in another sample.   */
  public java.lang.Boolean getIsSomatic() {
    return isSomatic;
  }

  /**
   * Sets the value of the 'isSomatic' field.
   * A boolean describing whether this variant call is somatic; in this case, the
   `referenceAllele` will have been observed in another sample.   * @param value the value to set.
   */
  public void setIsSomatic(java.lang.Boolean value) {
    this.isSomatic = value;
  }

  /** Creates a new Variant RecordBuilder */
  public static org.bdgenomics.formats.avro.Variant.Builder newBuilder() {
    return new org.bdgenomics.formats.avro.Variant.Builder();
  }
  
  /** Creates a new Variant RecordBuilder by copying an existing Builder */
  public static org.bdgenomics.formats.avro.Variant.Builder newBuilder(org.bdgenomics.formats.avro.Variant.Builder other) {
    return new org.bdgenomics.formats.avro.Variant.Builder(other);
  }
  
  /** Creates a new Variant RecordBuilder by copying an existing Variant instance */
  public static org.bdgenomics.formats.avro.Variant.Builder newBuilder(org.bdgenomics.formats.avro.Variant other) {
    return new org.bdgenomics.formats.avro.Variant.Builder(other);
  }
  
  /**
   * RecordBuilder for Variant instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<Variant>
    implements org.apache.avro.data.RecordBuilder<Variant> {

    private java.lang.Integer variantErrorProbability;
    private org.bdgenomics.formats.avro.Contig contig;
    private java.lang.Long start;
    private java.lang.Long end;
    private java.lang.CharSequence referenceAllele;
    private java.lang.CharSequence alternateAllele;
    private org.bdgenomics.formats.avro.StructuralVariant svAllele;
    private java.lang.Boolean isSomatic;

    /** Creates a new Builder */
    private Builder() {
      super(org.bdgenomics.formats.avro.Variant.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.bdgenomics.formats.avro.Variant.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.variantErrorProbability)) {
        this.variantErrorProbability = data().deepCopy(fields()[0].schema(), other.variantErrorProbability);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.end)) {
        this.end = data().deepCopy(fields()[3].schema(), other.end);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.referenceAllele)) {
        this.referenceAllele = data().deepCopy(fields()[4].schema(), other.referenceAllele);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.alternateAllele)) {
        this.alternateAllele = data().deepCopy(fields()[5].schema(), other.alternateAllele);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.svAllele)) {
        this.svAllele = data().deepCopy(fields()[6].schema(), other.svAllele);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.isSomatic)) {
        this.isSomatic = data().deepCopy(fields()[7].schema(), other.isSomatic);
        fieldSetFlags()[7] = true;
      }
    }
    
    /** Creates a Builder by copying an existing Variant instance */
    private Builder(org.bdgenomics.formats.avro.Variant other) {
            super(org.bdgenomics.formats.avro.Variant.SCHEMA$);
      if (isValidValue(fields()[0], other.variantErrorProbability)) {
        this.variantErrorProbability = data().deepCopy(fields()[0].schema(), other.variantErrorProbability);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.end)) {
        this.end = data().deepCopy(fields()[3].schema(), other.end);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.referenceAllele)) {
        this.referenceAllele = data().deepCopy(fields()[4].schema(), other.referenceAllele);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.alternateAllele)) {
        this.alternateAllele = data().deepCopy(fields()[5].schema(), other.alternateAllele);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.svAllele)) {
        this.svAllele = data().deepCopy(fields()[6].schema(), other.svAllele);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.isSomatic)) {
        this.isSomatic = data().deepCopy(fields()[7].schema(), other.isSomatic);
        fieldSetFlags()[7] = true;
      }
    }

    /** Gets the value of the 'variantErrorProbability' field */
    public java.lang.Integer getVariantErrorProbability() {
      return variantErrorProbability;
    }
    
    /** Sets the value of the 'variantErrorProbability' field */
    public org.bdgenomics.formats.avro.Variant.Builder setVariantErrorProbability(java.lang.Integer value) {
      validate(fields()[0], value);
      this.variantErrorProbability = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'variantErrorProbability' field has been set */
    public boolean hasVariantErrorProbability() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'variantErrorProbability' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearVariantErrorProbability() {
      variantErrorProbability = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.Contig getContig() {
      return contig;
    }
    
    /** Sets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.Variant.Builder setContig(org.bdgenomics.formats.avro.Contig value) {
      validate(fields()[1], value);
      this.contig = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'contig' field has been set */
    public boolean hasContig() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'contig' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearContig() {
      contig = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'start' field */
    public java.lang.Long getStart() {
      return start;
    }
    
    /** Sets the value of the 'start' field */
    public org.bdgenomics.formats.avro.Variant.Builder setStart(java.lang.Long value) {
      validate(fields()[2], value);
      this.start = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'start' field has been set */
    public boolean hasStart() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'start' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearStart() {
      start = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'end' field */
    public java.lang.Long getEnd() {
      return end;
    }
    
    /** Sets the value of the 'end' field */
    public org.bdgenomics.formats.avro.Variant.Builder setEnd(java.lang.Long value) {
      validate(fields()[3], value);
      this.end = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'end' field has been set */
    public boolean hasEnd() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'end' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearEnd() {
      end = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'referenceAllele' field */
    public java.lang.CharSequence getReferenceAllele() {
      return referenceAllele;
    }
    
    /** Sets the value of the 'referenceAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder setReferenceAllele(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.referenceAllele = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'referenceAllele' field has been set */
    public boolean hasReferenceAllele() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'referenceAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearReferenceAllele() {
      referenceAllele = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'alternateAllele' field */
    public java.lang.CharSequence getAlternateAllele() {
      return alternateAllele;
    }
    
    /** Sets the value of the 'alternateAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder setAlternateAllele(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.alternateAllele = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'alternateAllele' field has been set */
    public boolean hasAlternateAllele() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'alternateAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearAlternateAllele() {
      alternateAllele = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'svAllele' field */
    public org.bdgenomics.formats.avro.StructuralVariant getSvAllele() {
      return svAllele;
    }
    
    /** Sets the value of the 'svAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder setSvAllele(org.bdgenomics.formats.avro.StructuralVariant value) {
      validate(fields()[6], value);
      this.svAllele = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'svAllele' field has been set */
    public boolean hasSvAllele() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'svAllele' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearSvAllele() {
      svAllele = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'isSomatic' field */
    public java.lang.Boolean getIsSomatic() {
      return isSomatic;
    }
    
    /** Sets the value of the 'isSomatic' field */
    public org.bdgenomics.formats.avro.Variant.Builder setIsSomatic(java.lang.Boolean value) {
      validate(fields()[7], value);
      this.isSomatic = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'isSomatic' field has been set */
    public boolean hasIsSomatic() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'isSomatic' field */
    public org.bdgenomics.formats.avro.Variant.Builder clearIsSomatic() {
      isSomatic = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    @Override
    public Variant build() {
      try {
        Variant record = new Variant();
        record.variantErrorProbability = fieldSetFlags()[0] ? this.variantErrorProbability : (java.lang.Integer) defaultValue(fields()[0]);
        record.contig = fieldSetFlags()[1] ? this.contig : (org.bdgenomics.formats.avro.Contig) defaultValue(fields()[1]);
        record.start = fieldSetFlags()[2] ? this.start : (java.lang.Long) defaultValue(fields()[2]);
        record.end = fieldSetFlags()[3] ? this.end : (java.lang.Long) defaultValue(fields()[3]);
        record.referenceAllele = fieldSetFlags()[4] ? this.referenceAllele : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.alternateAllele = fieldSetFlags()[5] ? this.alternateAllele : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.svAllele = fieldSetFlags()[6] ? this.svAllele : (org.bdgenomics.formats.avro.StructuralVariant) defaultValue(fields()[6]);
        record.isSomatic = fieldSetFlags()[7] ? this.isSomatic : (java.lang.Boolean) defaultValue(fields()[7]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
