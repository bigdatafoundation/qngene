/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bdgenomics.formats.avro;  
@SuppressWarnings("all")
@org.apache.avro.specific.AvroGenerated
public class AlignmentRecord extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"AlignmentRecord\",\"namespace\":\"org.bdgenomics.formats.avro\",\"fields\":[{\"name\":\"readInFragment\",\"type\":[\"int\",\"null\"],\"doc\":\"Read number within the array of fragment reads.\",\"default\":0},{\"name\":\"contig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Contig\",\"doc\":\"Record for describing a reference assembly. Not used for storing the contents\\n of said assembly.\\n\\n @see NucleotideContigFragment\",\"fields\":[{\"name\":\"contigName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this contig in the assembly (e.g., \\\"chr1\\\").\",\"default\":null},{\"name\":\"contigLength\",\"type\":[\"null\",\"long\"],\"doc\":\"The length of this contig.\",\"default\":null},{\"name\":\"contigMD5\",\"type\":[\"null\",\"string\"],\"doc\":\"The MD5 checksum of the assembly for this contig.\",\"default\":null},{\"name\":\"referenceURL\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL at which this reference assembly can be found.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this assembly (e.g., \\\"hg19\\\").\",\"default\":null},{\"name\":\"species\",\"type\":[\"null\",\"string\"],\"doc\":\"The species that this assembly is for.\",\"default\":null},{\"name\":\"referenceIndex\",\"type\":[\"null\",\"int\"],\"doc\":\"Optional 0-based index of this contig in a SAM file header that it was read\\n   from; helps output SAMs/BAMs with headers in the same order as they started\\n   with, before a conversion to ADAM.\",\"default\":null}]}],\"doc\":\"The reference sequence details for the reference chromosome that\\n   this read is aligned to. If the read is unaligned, this field should\\n   be null.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the start of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"oldPosition\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position where this read used to start before\\n   local realignment.\\n   Stores the same data as the OP field in the SAM format.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the end of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"mapq\",\"type\":[\"null\",\"int\"],\"doc\":\"The global mapping quality of this read.\",\"default\":null},{\"name\":\"readName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this read. This should be unique within the read group\\n   that this read is from, and can be used to identify other reads that\\n   are derived from a single fragment.\",\"default\":null},{\"name\":\"sequence\",\"type\":[\"null\",\"string\"],\"doc\":\"The bases in this alignment. If the read has been hard clipped, this may\\n   not represent all the bases in the original read.\",\"default\":null},{\"name\":\"qual\",\"type\":[\"null\",\"string\"],\"doc\":\"The per-base quality scores in this alignment. If the read has been hard\\n   clipped, this may not represent all the bases in the original read.\\n   Additionally, if the error scores have been recalibrated, this field\\n   will not contain the original base quality scores.\\n\\n   @see origQual\",\"default\":null},{\"name\":\"cigar\",\"type\":[\"null\",\"string\"],\"doc\":\"The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that\\n   describes the local alignment of this read. Contains {length, operator}\\n   pairs for all contiguous alignment operations. The operators include:\\n\\n   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be\\n     aligned to the reference without evidence of an INDEL. Unlike the\\n     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH\\n     operator does not indicate whether the reference and read sequences are an\\n     exact match.\\n   * I, INSERT: The insert operator indicates that the read contains evidence of\\n     bases being inserted into the reference.\\n   * D, DELETE: The delete operator indicates that the read contains evidence of\\n     bases being deleted from the reference.\\n   * N, SKIP: The skip operator indicates that this read skips a long segment of\\n     the reference, but the bases have not been deleted. This operator is\\n     commonly used when working with RNA-seq data, where reads may skip long\\n     segments of the reference between exons.\\n   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end\\n     of a read have not been considered during alignment. This may occur if the\\n     majority of a read maps, except for low quality bases at the start/end of\\n     a read. Bases that are soft clipped will still be stored in the read.\\n   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of\\n     a read have been omitted from this alignment. This may occur if this linear\\n     alignment is part of a chimeric alignment, or if the read has been trimmed\\n     (e.g., during error correction, or to trim poly-A tails for RNA-seq).\\n   * P, PAD: The pad operator indicates that there is padding in an alignment.\\n   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned\\n     sequence exactly matches the reference (e.g., all bases are equal to the\\n     reference bases).\\n   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the\\n     aligned sequence is an alignment match to the reference, but a sequence\\n     mismatch (e.g., the bases are not equal to the reference). This can\\n     indicate a SNP or a read error.\",\"default\":null},{\"name\":\"oldCigar\",\"type\":[\"null\",\"string\"],\"doc\":\"Stores the CIGAR string present before local indel realignment.\\n   Stores the same data as the OC field in the SAM format.\\n\\n   @see cigar\",\"default\":null},{\"name\":\"basesTrimmedFromStart\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   start of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the start of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"basesTrimmedFromEnd\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   end of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the end of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"readPaired\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"properPair\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"mateMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"failedVendorQualityChecks\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"duplicateRead\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if this alignment is mapped as a reverse compliment. This field\\n   defaults to false.\",\"default\":false},{\"name\":\"mateNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if the mate pair of this alignment is mapped as a reverse compliment.\\n   This field defaults to false.\",\"default\":false},{\"name\":\"primaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is either the best linear alignment,\\n   or the first linear alignment in a chimeric alignment. Defaults to false.\\n\\n   @see secondaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"secondaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a lower quality linear alignment\\n   for a multiply-mapped read. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"supplementaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a non-primary linear alignment in\\n   a chimeric alignment. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see secondaryAlignment\",\"default\":false},{\"name\":\"mismatchingPositions\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"origQual\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"attributes\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupSample\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"mateAlignmentStart\",\"type\":[\"null\",\"long\"],\"doc\":\"The start position of the mate of this read. Should"," be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateAlignmentEnd\",\"type\":[\"null\",\"long\"],\"doc\":\"The end position of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateContig\",\"type\":[\"null\",\"Contig\"],\"doc\":\"The reference contig of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"inferredInsertSize\",\"type\":[\"null\",\"long\"],\"doc\":\"The distance between this read and it's mate as inferred from alignment.\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** Read number within the array of fragment reads. */
  @Deprecated public java.lang.Integer readInFragment;
  /** The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null. */
  @Deprecated public org.bdgenomics.formats.avro.Contig contig;
  /** 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned. */
  @Deprecated public java.lang.Long start;
  /** 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format. */
  @Deprecated public java.lang.Long oldPosition;
  /** 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned. */
  @Deprecated public java.lang.Long end;
  /** The global mapping quality of this read. */
  @Deprecated public java.lang.Integer mapq;
  /** The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment. */
  @Deprecated public java.lang.CharSequence readName;
  /** The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read. */
  @Deprecated public java.lang.CharSequence sequence;
  /** The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual */
  @Deprecated public java.lang.CharSequence qual;
  /** The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error. */
  @Deprecated public java.lang.CharSequence cigar;
  /** Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar */
  @Deprecated public java.lang.CharSequence oldCigar;
  /** The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar */
  @Deprecated public java.lang.Integer basesTrimmedFromStart;
  /** The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar */
  @Deprecated public java.lang.Integer basesTrimmedFromEnd;
  @Deprecated public java.lang.Boolean readPaired;
  @Deprecated public java.lang.Boolean properPair;
  @Deprecated public java.lang.Boolean readMapped;
  @Deprecated public java.lang.Boolean mateMapped;
  @Deprecated public java.lang.Boolean failedVendorQualityChecks;
  @Deprecated public java.lang.Boolean duplicateRead;
  /** True if this alignment is mapped as a reverse compliment. This field
   defaults to false. */
  @Deprecated public java.lang.Boolean readNegativeStrand;
  /** True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false. */
  @Deprecated public java.lang.Boolean mateNegativeStrand;
  /** This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment */
  @Deprecated public java.lang.Boolean primaryAlignment;
  /** This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment */
  @Deprecated public java.lang.Boolean secondaryAlignment;
  /** This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment */
  @Deprecated public java.lang.Boolean supplementaryAlignment;
  @Deprecated public java.lang.CharSequence mismatchingPositions;
  @Deprecated public java.lang.CharSequence origQual;
  @Deprecated public java.lang.CharSequence attributes;
  @Deprecated public java.lang.CharSequence recordGroupName;
  @Deprecated public java.lang.CharSequence recordGroupSample;
  /** The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public java.lang.Long mateAlignmentStart;
  /** The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public java.lang.Long mateAlignmentEnd;
  /** The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist. */
  @Deprecated public org.bdgenomics.formats.avro.Contig mateContig;
  /** The distance between this read and it's mate as inferred from alignment. */
  @Deprecated public java.lang.Long inferredInsertSize;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public AlignmentRecord() {}

  /**
   * All-args constructor.
   */
  public AlignmentRecord(java.lang.Integer readInFragment, org.bdgenomics.formats.avro.Contig contig, java.lang.Long start, java.lang.Long oldPosition, java.lang.Long end, java.lang.Integer mapq, java.lang.CharSequence readName, java.lang.CharSequence sequence, java.lang.CharSequence qual, java.lang.CharSequence cigar, java.lang.CharSequence oldCigar, java.lang.Integer basesTrimmedFromStart, java.lang.Integer basesTrimmedFromEnd, java.lang.Boolean readPaired, java.lang.Boolean properPair, java.lang.Boolean readMapped, java.lang.Boolean mateMapped, java.lang.Boolean failedVendorQualityChecks, java.lang.Boolean duplicateRead, java.lang.Boolean readNegativeStrand, java.lang.Boolean mateNegativeStrand, java.lang.Boolean primaryAlignment, java.lang.Boolean secondaryAlignment, java.lang.Boolean supplementaryAlignment, java.lang.CharSequence mismatchingPositions, java.lang.CharSequence origQual, java.lang.CharSequence attributes, java.lang.CharSequence recordGroupName, java.lang.CharSequence recordGroupSample, java.lang.Long mateAlignmentStart, java.lang.Long mateAlignmentEnd, org.bdgenomics.formats.avro.Contig mateContig, java.lang.Long inferredInsertSize) {
    this.readInFragment = readInFragment;
    this.contig = contig;
    this.start = start;
    this.oldPosition = oldPosition;
    this.end = end;
    this.mapq = mapq;
    this.readName = readName;
    this.sequence = sequence;
    this.qual = qual;
    this.cigar = cigar;
    this.oldCigar = oldCigar;
    this.basesTrimmedFromStart = basesTrimmedFromStart;
    this.basesTrimmedFromEnd = basesTrimmedFromEnd;
    this.readPaired = readPaired;
    this.properPair = properPair;
    this.readMapped = readMapped;
    this.mateMapped = mateMapped;
    this.failedVendorQualityChecks = failedVendorQualityChecks;
    this.duplicateRead = duplicateRead;
    this.readNegativeStrand = readNegativeStrand;
    this.mateNegativeStrand = mateNegativeStrand;
    this.primaryAlignment = primaryAlignment;
    this.secondaryAlignment = secondaryAlignment;
    this.supplementaryAlignment = supplementaryAlignment;
    this.mismatchingPositions = mismatchingPositions;
    this.origQual = origQual;
    this.attributes = attributes;
    this.recordGroupName = recordGroupName;
    this.recordGroupSample = recordGroupSample;
    this.mateAlignmentStart = mateAlignmentStart;
    this.mateAlignmentEnd = mateAlignmentEnd;
    this.mateContig = mateContig;
    this.inferredInsertSize = inferredInsertSize;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return readInFragment;
    case 1: return contig;
    case 2: return start;
    case 3: return oldPosition;
    case 4: return end;
    case 5: return mapq;
    case 6: return readName;
    case 7: return sequence;
    case 8: return qual;
    case 9: return cigar;
    case 10: return oldCigar;
    case 11: return basesTrimmedFromStart;
    case 12: return basesTrimmedFromEnd;
    case 13: return readPaired;
    case 14: return properPair;
    case 15: return readMapped;
    case 16: return mateMapped;
    case 17: return failedVendorQualityChecks;
    case 18: return duplicateRead;
    case 19: return readNegativeStrand;
    case 20: return mateNegativeStrand;
    case 21: return primaryAlignment;
    case 22: return secondaryAlignment;
    case 23: return supplementaryAlignment;
    case 24: return mismatchingPositions;
    case 25: return origQual;
    case 26: return attributes;
    case 27: return recordGroupName;
    case 28: return recordGroupSample;
    case 29: return mateAlignmentStart;
    case 30: return mateAlignmentEnd;
    case 31: return mateContig;
    case 32: return inferredInsertSize;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: readInFragment = (java.lang.Integer)value$; break;
    case 1: contig = (org.bdgenomics.formats.avro.Contig)value$; break;
    case 2: start = (java.lang.Long)value$; break;
    case 3: oldPosition = (java.lang.Long)value$; break;
    case 4: end = (java.lang.Long)value$; break;
    case 5: mapq = (java.lang.Integer)value$; break;
    case 6: readName = (java.lang.CharSequence)value$; break;
    case 7: sequence = (java.lang.CharSequence)value$; break;
    case 8: qual = (java.lang.CharSequence)value$; break;
    case 9: cigar = (java.lang.CharSequence)value$; break;
    case 10: oldCigar = (java.lang.CharSequence)value$; break;
    case 11: basesTrimmedFromStart = (java.lang.Integer)value$; break;
    case 12: basesTrimmedFromEnd = (java.lang.Integer)value$; break;
    case 13: readPaired = (java.lang.Boolean)value$; break;
    case 14: properPair = (java.lang.Boolean)value$; break;
    case 15: readMapped = (java.lang.Boolean)value$; break;
    case 16: mateMapped = (java.lang.Boolean)value$; break;
    case 17: failedVendorQualityChecks = (java.lang.Boolean)value$; break;
    case 18: duplicateRead = (java.lang.Boolean)value$; break;
    case 19: readNegativeStrand = (java.lang.Boolean)value$; break;
    case 20: mateNegativeStrand = (java.lang.Boolean)value$; break;
    case 21: primaryAlignment = (java.lang.Boolean)value$; break;
    case 22: secondaryAlignment = (java.lang.Boolean)value$; break;
    case 23: supplementaryAlignment = (java.lang.Boolean)value$; break;
    case 24: mismatchingPositions = (java.lang.CharSequence)value$; break;
    case 25: origQual = (java.lang.CharSequence)value$; break;
    case 26: attributes = (java.lang.CharSequence)value$; break;
    case 27: recordGroupName = (java.lang.CharSequence)value$; break;
    case 28: recordGroupSample = (java.lang.CharSequence)value$; break;
    case 29: mateAlignmentStart = (java.lang.Long)value$; break;
    case 30: mateAlignmentEnd = (java.lang.Long)value$; break;
    case 31: mateContig = (org.bdgenomics.formats.avro.Contig)value$; break;
    case 32: inferredInsertSize = (java.lang.Long)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'readInFragment' field.
   * Read number within the array of fragment reads.   */
  public java.lang.Integer getReadInFragment() {
    return readInFragment;
  }

  /**
   * Sets the value of the 'readInFragment' field.
   * Read number within the array of fragment reads.   * @param value the value to set.
   */
  public void setReadInFragment(java.lang.Integer value) {
    this.readInFragment = value;
  }

  /**
   * Gets the value of the 'contig' field.
   * The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null.   */
  public org.bdgenomics.formats.avro.Contig getContig() {
    return contig;
  }

  /**
   * Sets the value of the 'contig' field.
   * The reference sequence details for the reference chromosome that
   this read is aligned to. If the read is unaligned, this field should
   be null.   * @param value the value to set.
   */
  public void setContig(org.bdgenomics.formats.avro.Contig value) {
    this.contig = value;
  }

  /**
   * Gets the value of the 'start' field.
   * 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned.   */
  public java.lang.Long getStart() {
    return start;
  }

  /**
   * Sets the value of the 'start' field.
   * 0 based reference position for the start of this read's alignment.
   Should be null if the read is unaligned.   * @param value the value to set.
   */
  public void setStart(java.lang.Long value) {
    this.start = value;
  }

  /**
   * Gets the value of the 'oldPosition' field.
   * 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format.   */
  public java.lang.Long getOldPosition() {
    return oldPosition;
  }

  /**
   * Sets the value of the 'oldPosition' field.
   * 0 based reference position where this read used to start before
   local realignment.
   Stores the same data as the OP field in the SAM format.   * @param value the value to set.
   */
  public void setOldPosition(java.lang.Long value) {
    this.oldPosition = value;
  }

  /**
   * Gets the value of the 'end' field.
   * 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned.   */
  public java.lang.Long getEnd() {
    return end;
  }

  /**
   * Sets the value of the 'end' field.
   * 0 based reference position for the end of this read's alignment.
   Should be null if the read is unaligned.   * @param value the value to set.
   */
  public void setEnd(java.lang.Long value) {
    this.end = value;
  }

  /**
   * Gets the value of the 'mapq' field.
   * The global mapping quality of this read.   */
  public java.lang.Integer getMapq() {
    return mapq;
  }

  /**
   * Sets the value of the 'mapq' field.
   * The global mapping quality of this read.   * @param value the value to set.
   */
  public void setMapq(java.lang.Integer value) {
    this.mapq = value;
  }

  /**
   * Gets the value of the 'readName' field.
   * The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment.   */
  public java.lang.CharSequence getReadName() {
    return readName;
  }

  /**
   * Sets the value of the 'readName' field.
   * The name of this read. This should be unique within the read group
   that this read is from, and can be used to identify other reads that
   are derived from a single fragment.   * @param value the value to set.
   */
  public void setReadName(java.lang.CharSequence value) {
    this.readName = value;
  }

  /**
   * Gets the value of the 'sequence' field.
   * The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read.   */
  public java.lang.CharSequence getSequence() {
    return sequence;
  }

  /**
   * Sets the value of the 'sequence' field.
   * The bases in this alignment. If the read has been hard clipped, this may
   not represent all the bases in the original read.   * @param value the value to set.
   */
  public void setSequence(java.lang.CharSequence value) {
    this.sequence = value;
  }

  /**
   * Gets the value of the 'qual' field.
   * The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual   */
  public java.lang.CharSequence getQual() {
    return qual;
  }

  /**
   * Sets the value of the 'qual' field.
   * The per-base quality scores in this alignment. If the read has been hard
   clipped, this may not represent all the bases in the original read.
   Additionally, if the error scores have been recalibrated, this field
   will not contain the original base quality scores.

   @see origQual   * @param value the value to set.
   */
  public void setQual(java.lang.CharSequence value) {
    this.qual = value;
  }

  /**
   * Gets the value of the 'cigar' field.
   * The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error.   */
  public java.lang.CharSequence getCigar() {
    return cigar;
  }

  /**
   * Sets the value of the 'cigar' field.
   * The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that
   describes the local alignment of this read. Contains {length, operator}
   pairs for all contiguous alignment operations. The operators include:

   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be
     aligned to the reference without evidence of an INDEL. Unlike the
     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH
     operator does not indicate whether the reference and read sequences are an
     exact match.
   * I, INSERT: The insert operator indicates that the read contains evidence of
     bases being inserted into the reference.
   * D, DELETE: The delete operator indicates that the read contains evidence of
     bases being deleted from the reference.
   * N, SKIP: The skip operator indicates that this read skips a long segment of
     the reference, but the bases have not been deleted. This operator is
     commonly used when working with RNA-seq data, where reads may skip long
     segments of the reference between exons.
   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end
     of a read have not been considered during alignment. This may occur if the
     majority of a read maps, except for low quality bases at the start/end of
     a read. Bases that are soft clipped will still be stored in the read.
   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of
     a read have been omitted from this alignment. This may occur if this linear
     alignment is part of a chimeric alignment, or if the read has been trimmed
     (e.g., during error correction, or to trim poly-A tails for RNA-seq).
   * P, PAD: The pad operator indicates that there is padding in an alignment.
   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned
     sequence exactly matches the reference (e.g., all bases are equal to the
     reference bases).
   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the
     aligned sequence is an alignment match to the reference, but a sequence
     mismatch (e.g., the bases are not equal to the reference). This can
     indicate a SNP or a read error.   * @param value the value to set.
   */
  public void setCigar(java.lang.CharSequence value) {
    this.cigar = value;
  }

  /**
   * Gets the value of the 'oldCigar' field.
   * Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar   */
  public java.lang.CharSequence getOldCigar() {
    return oldCigar;
  }

  /**
   * Sets the value of the 'oldCigar' field.
   * Stores the CIGAR string present before local indel realignment.
   Stores the same data as the OC field in the SAM format.

   @see cigar   * @param value the value to set.
   */
  public void setOldCigar(java.lang.CharSequence value) {
    this.oldCigar = value;
  }

  /**
   * Gets the value of the 'basesTrimmedFromStart' field.
   * The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar   */
  public java.lang.Integer getBasesTrimmedFromStart() {
    return basesTrimmedFromStart;
  }

  /**
   * Sets the value of the 'basesTrimmedFromStart' field.
   * The number of bases in this read/alignment that have been trimmed from the
   start of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the start of the read has been hard-clipped.

   @see cigar   * @param value the value to set.
   */
  public void setBasesTrimmedFromStart(java.lang.Integer value) {
    this.basesTrimmedFromStart = value;
  }

  /**
   * Gets the value of the 'basesTrimmedFromEnd' field.
   * The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar   */
  public java.lang.Integer getBasesTrimmedFromEnd() {
    return basesTrimmedFromEnd;
  }

  /**
   * Sets the value of the 'basesTrimmedFromEnd' field.
   * The number of bases in this read/alignment that have been trimmed from the
   end of the read. By default, this is equal to 0. If the value is non-zero,
   that means that the end of the read has been hard-clipped.

   @see cigar   * @param value the value to set.
   */
  public void setBasesTrimmedFromEnd(java.lang.Integer value) {
    this.basesTrimmedFromEnd = value;
  }

  /**
   * Gets the value of the 'readPaired' field.
   */
  public java.lang.Boolean getReadPaired() {
    return readPaired;
  }

  /**
   * Sets the value of the 'readPaired' field.
   * @param value the value to set.
   */
  public void setReadPaired(java.lang.Boolean value) {
    this.readPaired = value;
  }

  /**
   * Gets the value of the 'properPair' field.
   */
  public java.lang.Boolean getProperPair() {
    return properPair;
  }

  /**
   * Sets the value of the 'properPair' field.
   * @param value the value to set.
   */
  public void setProperPair(java.lang.Boolean value) {
    this.properPair = value;
  }

  /**
   * Gets the value of the 'readMapped' field.
   */
  public java.lang.Boolean getReadMapped() {
    return readMapped;
  }

  /**
   * Sets the value of the 'readMapped' field.
   * @param value the value to set.
   */
  public void setReadMapped(java.lang.Boolean value) {
    this.readMapped = value;
  }

  /**
   * Gets the value of the 'mateMapped' field.
   */
  public java.lang.Boolean getMateMapped() {
    return mateMapped;
  }

  /**
   * Sets the value of the 'mateMapped' field.
   * @param value the value to set.
   */
  public void setMateMapped(java.lang.Boolean value) {
    this.mateMapped = value;
  }

  /**
   * Gets the value of the 'failedVendorQualityChecks' field.
   */
  public java.lang.Boolean getFailedVendorQualityChecks() {
    return failedVendorQualityChecks;
  }

  /**
   * Sets the value of the 'failedVendorQualityChecks' field.
   * @param value the value to set.
   */
  public void setFailedVendorQualityChecks(java.lang.Boolean value) {
    this.failedVendorQualityChecks = value;
  }

  /**
   * Gets the value of the 'duplicateRead' field.
   */
  public java.lang.Boolean getDuplicateRead() {
    return duplicateRead;
  }

  /**
   * Sets the value of the 'duplicateRead' field.
   * @param value the value to set.
   */
  public void setDuplicateRead(java.lang.Boolean value) {
    this.duplicateRead = value;
  }

  /**
   * Gets the value of the 'readNegativeStrand' field.
   * True if this alignment is mapped as a reverse compliment. This field
   defaults to false.   */
  public java.lang.Boolean getReadNegativeStrand() {
    return readNegativeStrand;
  }

  /**
   * Sets the value of the 'readNegativeStrand' field.
   * True if this alignment is mapped as a reverse compliment. This field
   defaults to false.   * @param value the value to set.
   */
  public void setReadNegativeStrand(java.lang.Boolean value) {
    this.readNegativeStrand = value;
  }

  /**
   * Gets the value of the 'mateNegativeStrand' field.
   * True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false.   */
  public java.lang.Boolean getMateNegativeStrand() {
    return mateNegativeStrand;
  }

  /**
   * Sets the value of the 'mateNegativeStrand' field.
   * True if the mate pair of this alignment is mapped as a reverse compliment.
   This field defaults to false.   * @param value the value to set.
   */
  public void setMateNegativeStrand(java.lang.Boolean value) {
    this.mateNegativeStrand = value;
  }

  /**
   * Gets the value of the 'primaryAlignment' field.
   * This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment   */
  public java.lang.Boolean getPrimaryAlignment() {
    return primaryAlignment;
  }

  /**
   * Sets the value of the 'primaryAlignment' field.
   * This field is true if this alignment is either the best linear alignment,
   or the first linear alignment in a chimeric alignment. Defaults to false.

   @see secondaryAlignment
   @see supplementaryAlignment   * @param value the value to set.
   */
  public void setPrimaryAlignment(java.lang.Boolean value) {
    this.primaryAlignment = value;
  }

  /**
   * Gets the value of the 'secondaryAlignment' field.
   * This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment   */
  public java.lang.Boolean getSecondaryAlignment() {
    return secondaryAlignment;
  }

  /**
   * Sets the value of the 'secondaryAlignment' field.
   * This field is true if this alignment is a lower quality linear alignment
   for a multiply-mapped read. Defaults to false.

   @see primaryAlignment
   @see supplementaryAlignment   * @param value the value to set.
   */
  public void setSecondaryAlignment(java.lang.Boolean value) {
    this.secondaryAlignment = value;
  }

  /**
   * Gets the value of the 'supplementaryAlignment' field.
   * This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment   */
  public java.lang.Boolean getSupplementaryAlignment() {
    return supplementaryAlignment;
  }

  /**
   * Sets the value of the 'supplementaryAlignment' field.
   * This field is true if this alignment is a non-primary linear alignment in
   a chimeric alignment. Defaults to false.

   @see primaryAlignment
   @see secondaryAlignment   * @param value the value to set.
   */
  public void setSupplementaryAlignment(java.lang.Boolean value) {
    this.supplementaryAlignment = value;
  }

  /**
   * Gets the value of the 'mismatchingPositions' field.
   */
  public java.lang.CharSequence getMismatchingPositions() {
    return mismatchingPositions;
  }

  /**
   * Sets the value of the 'mismatchingPositions' field.
   * @param value the value to set.
   */
  public void setMismatchingPositions(java.lang.CharSequence value) {
    this.mismatchingPositions = value;
  }

  /**
   * Gets the value of the 'origQual' field.
   */
  public java.lang.CharSequence getOrigQual() {
    return origQual;
  }

  /**
   * Sets the value of the 'origQual' field.
   * @param value the value to set.
   */
  public void setOrigQual(java.lang.CharSequence value) {
    this.origQual = value;
  }

  /**
   * Gets the value of the 'attributes' field.
   */
  public java.lang.CharSequence getAttributes() {
    return attributes;
  }

  /**
   * Sets the value of the 'attributes' field.
   * @param value the value to set.
   */
  public void setAttributes(java.lang.CharSequence value) {
    this.attributes = value;
  }

  /**
   * Gets the value of the 'recordGroupName' field.
   */
  public java.lang.CharSequence getRecordGroupName() {
    return recordGroupName;
  }

  /**
   * Sets the value of the 'recordGroupName' field.
   * @param value the value to set.
   */
  public void setRecordGroupName(java.lang.CharSequence value) {
    this.recordGroupName = value;
  }

  /**
   * Gets the value of the 'recordGroupSample' field.
   */
  public java.lang.CharSequence getRecordGroupSample() {
    return recordGroupSample;
  }

  /**
   * Sets the value of the 'recordGroupSample' field.
   * @param value the value to set.
   */
  public void setRecordGroupSample(java.lang.CharSequence value) {
    this.recordGroupSample = value;
  }

  /**
   * Gets the value of the 'mateAlignmentStart' field.
   * The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public java.lang.Long getMateAlignmentStart() {
    return mateAlignmentStart;
  }

  /**
   * Sets the value of the 'mateAlignmentStart' field.
   * The start position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateAlignmentStart(java.lang.Long value) {
    this.mateAlignmentStart = value;
  }

  /**
   * Gets the value of the 'mateAlignmentEnd' field.
   * The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public java.lang.Long getMateAlignmentEnd() {
    return mateAlignmentEnd;
  }

  /**
   * Sets the value of the 'mateAlignmentEnd' field.
   * The end position of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateAlignmentEnd(java.lang.Long value) {
    this.mateAlignmentEnd = value;
  }

  /**
   * Gets the value of the 'mateContig' field.
   * The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   */
  public org.bdgenomics.formats.avro.Contig getMateContig() {
    return mateContig;
  }

  /**
   * Sets the value of the 'mateContig' field.
   * The reference contig of the mate of this read. Should be set to null if the
   mate is unaligned, or if the mate does not exist.   * @param value the value to set.
   */
  public void setMateContig(org.bdgenomics.formats.avro.Contig value) {
    this.mateContig = value;
  }

  /**
   * Gets the value of the 'inferredInsertSize' field.
   * The distance between this read and it's mate as inferred from alignment.   */
  public java.lang.Long getInferredInsertSize() {
    return inferredInsertSize;
  }

  /**
   * Sets the value of the 'inferredInsertSize' field.
   * The distance between this read and it's mate as inferred from alignment.   * @param value the value to set.
   */
  public void setInferredInsertSize(java.lang.Long value) {
    this.inferredInsertSize = value;
  }

  /** Creates a new AlignmentRecord RecordBuilder */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder() {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder();
  }
  
  /** Creates a new AlignmentRecord RecordBuilder by copying an existing Builder */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder(org.bdgenomics.formats.avro.AlignmentRecord.Builder other) {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder(other);
  }
  
  /** Creates a new AlignmentRecord RecordBuilder by copying an existing AlignmentRecord instance */
  public static org.bdgenomics.formats.avro.AlignmentRecord.Builder newBuilder(org.bdgenomics.formats.avro.AlignmentRecord other) {
    return new org.bdgenomics.formats.avro.AlignmentRecord.Builder(other);
  }
  
  /**
   * RecordBuilder for AlignmentRecord instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<AlignmentRecord>
    implements org.apache.avro.data.RecordBuilder<AlignmentRecord> {

    private java.lang.Integer readInFragment;
    private org.bdgenomics.formats.avro.Contig contig;
    private java.lang.Long start;
    private java.lang.Long oldPosition;
    private java.lang.Long end;
    private java.lang.Integer mapq;
    private java.lang.CharSequence readName;
    private java.lang.CharSequence sequence;
    private java.lang.CharSequence qual;
    private java.lang.CharSequence cigar;
    private java.lang.CharSequence oldCigar;
    private java.lang.Integer basesTrimmedFromStart;
    private java.lang.Integer basesTrimmedFromEnd;
    private java.lang.Boolean readPaired;
    private java.lang.Boolean properPair;
    private java.lang.Boolean readMapped;
    private java.lang.Boolean mateMapped;
    private java.lang.Boolean failedVendorQualityChecks;
    private java.lang.Boolean duplicateRead;
    private java.lang.Boolean readNegativeStrand;
    private java.lang.Boolean mateNegativeStrand;
    private java.lang.Boolean primaryAlignment;
    private java.lang.Boolean secondaryAlignment;
    private java.lang.Boolean supplementaryAlignment;
    private java.lang.CharSequence mismatchingPositions;
    private java.lang.CharSequence origQual;
    private java.lang.CharSequence attributes;
    private java.lang.CharSequence recordGroupName;
    private java.lang.CharSequence recordGroupSample;
    private java.lang.Long mateAlignmentStart;
    private java.lang.Long mateAlignmentEnd;
    private org.bdgenomics.formats.avro.Contig mateContig;
    private java.lang.Long inferredInsertSize;

    /** Creates a new Builder */
    private Builder() {
      super(org.bdgenomics.formats.avro.AlignmentRecord.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.bdgenomics.formats.avro.AlignmentRecord.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.readInFragment)) {
        this.readInFragment = data().deepCopy(fields()[0].schema(), other.readInFragment);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.oldPosition)) {
        this.oldPosition = data().deepCopy(fields()[3].schema(), other.oldPosition);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.end)) {
        this.end = data().deepCopy(fields()[4].schema(), other.end);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.mapq)) {
        this.mapq = data().deepCopy(fields()[5].schema(), other.mapq);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.readName)) {
        this.readName = data().deepCopy(fields()[6].schema(), other.readName);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.sequence)) {
        this.sequence = data().deepCopy(fields()[7].schema(), other.sequence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.qual)) {
        this.qual = data().deepCopy(fields()[8].schema(), other.qual);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.cigar)) {
        this.cigar = data().deepCopy(fields()[9].schema(), other.cigar);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.oldCigar)) {
        this.oldCigar = data().deepCopy(fields()[10].schema(), other.oldCigar);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.basesTrimmedFromStart)) {
        this.basesTrimmedFromStart = data().deepCopy(fields()[11].schema(), other.basesTrimmedFromStart);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.basesTrimmedFromEnd)) {
        this.basesTrimmedFromEnd = data().deepCopy(fields()[12].schema(), other.basesTrimmedFromEnd);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.readPaired)) {
        this.readPaired = data().deepCopy(fields()[13].schema(), other.readPaired);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.properPair)) {
        this.properPair = data().deepCopy(fields()[14].schema(), other.properPair);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.readMapped)) {
        this.readMapped = data().deepCopy(fields()[15].schema(), other.readMapped);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.mateMapped)) {
        this.mateMapped = data().deepCopy(fields()[16].schema(), other.mateMapped);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[17].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.duplicateRead)) {
        this.duplicateRead = data().deepCopy(fields()[18].schema(), other.duplicateRead);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.readNegativeStrand)) {
        this.readNegativeStrand = data().deepCopy(fields()[19].schema(), other.readNegativeStrand);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.mateNegativeStrand)) {
        this.mateNegativeStrand = data().deepCopy(fields()[20].schema(), other.mateNegativeStrand);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.primaryAlignment)) {
        this.primaryAlignment = data().deepCopy(fields()[21].schema(), other.primaryAlignment);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[22].schema(), other.secondaryAlignment);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[23].schema(), other.supplementaryAlignment);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.mismatchingPositions)) {
        this.mismatchingPositions = data().deepCopy(fields()[24].schema(), other.mismatchingPositions);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.origQual)) {
        this.origQual = data().deepCopy(fields()[25].schema(), other.origQual);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.attributes)) {
        this.attributes = data().deepCopy(fields()[26].schema(), other.attributes);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.recordGroupName)) {
        this.recordGroupName = data().deepCopy(fields()[27].schema(), other.recordGroupName);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.recordGroupSample)) {
        this.recordGroupSample = data().deepCopy(fields()[28].schema(), other.recordGroupSample);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.mateAlignmentStart)) {
        this.mateAlignmentStart = data().deepCopy(fields()[29].schema(), other.mateAlignmentStart);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.mateAlignmentEnd)) {
        this.mateAlignmentEnd = data().deepCopy(fields()[30].schema(), other.mateAlignmentEnd);
        fieldSetFlags()[30] = true;
      }
      if (isValidValue(fields()[31], other.mateContig)) {
        this.mateContig = data().deepCopy(fields()[31].schema(), other.mateContig);
        fieldSetFlags()[31] = true;
      }
      if (isValidValue(fields()[32], other.inferredInsertSize)) {
        this.inferredInsertSize = data().deepCopy(fields()[32].schema(), other.inferredInsertSize);
        fieldSetFlags()[32] = true;
      }
    }
    
    /** Creates a Builder by copying an existing AlignmentRecord instance */
    private Builder(org.bdgenomics.formats.avro.AlignmentRecord other) {
            super(org.bdgenomics.formats.avro.AlignmentRecord.SCHEMA$);
      if (isValidValue(fields()[0], other.readInFragment)) {
        this.readInFragment = data().deepCopy(fields()[0].schema(), other.readInFragment);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.contig)) {
        this.contig = data().deepCopy(fields()[1].schema(), other.contig);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.start)) {
        this.start = data().deepCopy(fields()[2].schema(), other.start);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.oldPosition)) {
        this.oldPosition = data().deepCopy(fields()[3].schema(), other.oldPosition);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.end)) {
        this.end = data().deepCopy(fields()[4].schema(), other.end);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.mapq)) {
        this.mapq = data().deepCopy(fields()[5].schema(), other.mapq);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.readName)) {
        this.readName = data().deepCopy(fields()[6].schema(), other.readName);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.sequence)) {
        this.sequence = data().deepCopy(fields()[7].schema(), other.sequence);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.qual)) {
        this.qual = data().deepCopy(fields()[8].schema(), other.qual);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.cigar)) {
        this.cigar = data().deepCopy(fields()[9].schema(), other.cigar);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.oldCigar)) {
        this.oldCigar = data().deepCopy(fields()[10].schema(), other.oldCigar);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.basesTrimmedFromStart)) {
        this.basesTrimmedFromStart = data().deepCopy(fields()[11].schema(), other.basesTrimmedFromStart);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.basesTrimmedFromEnd)) {
        this.basesTrimmedFromEnd = data().deepCopy(fields()[12].schema(), other.basesTrimmedFromEnd);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.readPaired)) {
        this.readPaired = data().deepCopy(fields()[13].schema(), other.readPaired);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.properPair)) {
        this.properPair = data().deepCopy(fields()[14].schema(), other.properPair);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.readMapped)) {
        this.readMapped = data().deepCopy(fields()[15].schema(), other.readMapped);
        fieldSetFlags()[15] = true;
      }
      if (isValidValue(fields()[16], other.mateMapped)) {
        this.mateMapped = data().deepCopy(fields()[16].schema(), other.mateMapped);
        fieldSetFlags()[16] = true;
      }
      if (isValidValue(fields()[17], other.failedVendorQualityChecks)) {
        this.failedVendorQualityChecks = data().deepCopy(fields()[17].schema(), other.failedVendorQualityChecks);
        fieldSetFlags()[17] = true;
      }
      if (isValidValue(fields()[18], other.duplicateRead)) {
        this.duplicateRead = data().deepCopy(fields()[18].schema(), other.duplicateRead);
        fieldSetFlags()[18] = true;
      }
      if (isValidValue(fields()[19], other.readNegativeStrand)) {
        this.readNegativeStrand = data().deepCopy(fields()[19].schema(), other.readNegativeStrand);
        fieldSetFlags()[19] = true;
      }
      if (isValidValue(fields()[20], other.mateNegativeStrand)) {
        this.mateNegativeStrand = data().deepCopy(fields()[20].schema(), other.mateNegativeStrand);
        fieldSetFlags()[20] = true;
      }
      if (isValidValue(fields()[21], other.primaryAlignment)) {
        this.primaryAlignment = data().deepCopy(fields()[21].schema(), other.primaryAlignment);
        fieldSetFlags()[21] = true;
      }
      if (isValidValue(fields()[22], other.secondaryAlignment)) {
        this.secondaryAlignment = data().deepCopy(fields()[22].schema(), other.secondaryAlignment);
        fieldSetFlags()[22] = true;
      }
      if (isValidValue(fields()[23], other.supplementaryAlignment)) {
        this.supplementaryAlignment = data().deepCopy(fields()[23].schema(), other.supplementaryAlignment);
        fieldSetFlags()[23] = true;
      }
      if (isValidValue(fields()[24], other.mismatchingPositions)) {
        this.mismatchingPositions = data().deepCopy(fields()[24].schema(), other.mismatchingPositions);
        fieldSetFlags()[24] = true;
      }
      if (isValidValue(fields()[25], other.origQual)) {
        this.origQual = data().deepCopy(fields()[25].schema(), other.origQual);
        fieldSetFlags()[25] = true;
      }
      if (isValidValue(fields()[26], other.attributes)) {
        this.attributes = data().deepCopy(fields()[26].schema(), other.attributes);
        fieldSetFlags()[26] = true;
      }
      if (isValidValue(fields()[27], other.recordGroupName)) {
        this.recordGroupName = data().deepCopy(fields()[27].schema(), other.recordGroupName);
        fieldSetFlags()[27] = true;
      }
      if (isValidValue(fields()[28], other.recordGroupSample)) {
        this.recordGroupSample = data().deepCopy(fields()[28].schema(), other.recordGroupSample);
        fieldSetFlags()[28] = true;
      }
      if (isValidValue(fields()[29], other.mateAlignmentStart)) {
        this.mateAlignmentStart = data().deepCopy(fields()[29].schema(), other.mateAlignmentStart);
        fieldSetFlags()[29] = true;
      }
      if (isValidValue(fields()[30], other.mateAlignmentEnd)) {
        this.mateAlignmentEnd = data().deepCopy(fields()[30].schema(), other.mateAlignmentEnd);
        fieldSetFlags()[30] = true;
      }
      if (isValidValue(fields()[31], other.mateContig)) {
        this.mateContig = data().deepCopy(fields()[31].schema(), other.mateContig);
        fieldSetFlags()[31] = true;
      }
      if (isValidValue(fields()[32], other.inferredInsertSize)) {
        this.inferredInsertSize = data().deepCopy(fields()[32].schema(), other.inferredInsertSize);
        fieldSetFlags()[32] = true;
      }
    }

    /** Gets the value of the 'readInFragment' field */
    public java.lang.Integer getReadInFragment() {
      return readInFragment;
    }
    
    /** Sets the value of the 'readInFragment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadInFragment(java.lang.Integer value) {
      validate(fields()[0], value);
      this.readInFragment = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'readInFragment' field has been set */
    public boolean hasReadInFragment() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'readInFragment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadInFragment() {
      readInFragment = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.Contig getContig() {
      return contig;
    }
    
    /** Sets the value of the 'contig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setContig(org.bdgenomics.formats.avro.Contig value) {
      validate(fields()[1], value);
      this.contig = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'contig' field has been set */
    public boolean hasContig() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'contig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearContig() {
      contig = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'start' field */
    public java.lang.Long getStart() {
      return start;
    }
    
    /** Sets the value of the 'start' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setStart(java.lang.Long value) {
      validate(fields()[2], value);
      this.start = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'start' field has been set */
    public boolean hasStart() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'start' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearStart() {
      start = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'oldPosition' field */
    public java.lang.Long getOldPosition() {
      return oldPosition;
    }
    
    /** Sets the value of the 'oldPosition' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOldPosition(java.lang.Long value) {
      validate(fields()[3], value);
      this.oldPosition = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'oldPosition' field has been set */
    public boolean hasOldPosition() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'oldPosition' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOldPosition() {
      oldPosition = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'end' field */
    public java.lang.Long getEnd() {
      return end;
    }
    
    /** Sets the value of the 'end' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setEnd(java.lang.Long value) {
      validate(fields()[4], value);
      this.end = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'end' field has been set */
    public boolean hasEnd() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'end' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearEnd() {
      end = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /** Gets the value of the 'mapq' field */
    public java.lang.Integer getMapq() {
      return mapq;
    }
    
    /** Sets the value of the 'mapq' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMapq(java.lang.Integer value) {
      validate(fields()[5], value);
      this.mapq = value;
      fieldSetFlags()[5] = true;
      return this; 
    }
    
    /** Checks whether the 'mapq' field has been set */
    public boolean hasMapq() {
      return fieldSetFlags()[5];
    }
    
    /** Clears the value of the 'mapq' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMapq() {
      mapq = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /** Gets the value of the 'readName' field */
    public java.lang.CharSequence getReadName() {
      return readName;
    }
    
    /** Sets the value of the 'readName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadName(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.readName = value;
      fieldSetFlags()[6] = true;
      return this; 
    }
    
    /** Checks whether the 'readName' field has been set */
    public boolean hasReadName() {
      return fieldSetFlags()[6];
    }
    
    /** Clears the value of the 'readName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadName() {
      readName = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /** Gets the value of the 'sequence' field */
    public java.lang.CharSequence getSequence() {
      return sequence;
    }
    
    /** Sets the value of the 'sequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSequence(java.lang.CharSequence value) {
      validate(fields()[7], value);
      this.sequence = value;
      fieldSetFlags()[7] = true;
      return this; 
    }
    
    /** Checks whether the 'sequence' field has been set */
    public boolean hasSequence() {
      return fieldSetFlags()[7];
    }
    
    /** Clears the value of the 'sequence' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSequence() {
      sequence = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /** Gets the value of the 'qual' field */
    public java.lang.CharSequence getQual() {
      return qual;
    }
    
    /** Sets the value of the 'qual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setQual(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.qual = value;
      fieldSetFlags()[8] = true;
      return this; 
    }
    
    /** Checks whether the 'qual' field has been set */
    public boolean hasQual() {
      return fieldSetFlags()[8];
    }
    
    /** Clears the value of the 'qual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearQual() {
      qual = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /** Gets the value of the 'cigar' field */
    public java.lang.CharSequence getCigar() {
      return cigar;
    }
    
    /** Sets the value of the 'cigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setCigar(java.lang.CharSequence value) {
      validate(fields()[9], value);
      this.cigar = value;
      fieldSetFlags()[9] = true;
      return this; 
    }
    
    /** Checks whether the 'cigar' field has been set */
    public boolean hasCigar() {
      return fieldSetFlags()[9];
    }
    
    /** Clears the value of the 'cigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearCigar() {
      cigar = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /** Gets the value of the 'oldCigar' field */
    public java.lang.CharSequence getOldCigar() {
      return oldCigar;
    }
    
    /** Sets the value of the 'oldCigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOldCigar(java.lang.CharSequence value) {
      validate(fields()[10], value);
      this.oldCigar = value;
      fieldSetFlags()[10] = true;
      return this; 
    }
    
    /** Checks whether the 'oldCigar' field has been set */
    public boolean hasOldCigar() {
      return fieldSetFlags()[10];
    }
    
    /** Clears the value of the 'oldCigar' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOldCigar() {
      oldCigar = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /** Gets the value of the 'basesTrimmedFromStart' field */
    public java.lang.Integer getBasesTrimmedFromStart() {
      return basesTrimmedFromStart;
    }
    
    /** Sets the value of the 'basesTrimmedFromStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setBasesTrimmedFromStart(java.lang.Integer value) {
      validate(fields()[11], value);
      this.basesTrimmedFromStart = value;
      fieldSetFlags()[11] = true;
      return this; 
    }
    
    /** Checks whether the 'basesTrimmedFromStart' field has been set */
    public boolean hasBasesTrimmedFromStart() {
      return fieldSetFlags()[11];
    }
    
    /** Clears the value of the 'basesTrimmedFromStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearBasesTrimmedFromStart() {
      basesTrimmedFromStart = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /** Gets the value of the 'basesTrimmedFromEnd' field */
    public java.lang.Integer getBasesTrimmedFromEnd() {
      return basesTrimmedFromEnd;
    }
    
    /** Sets the value of the 'basesTrimmedFromEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setBasesTrimmedFromEnd(java.lang.Integer value) {
      validate(fields()[12], value);
      this.basesTrimmedFromEnd = value;
      fieldSetFlags()[12] = true;
      return this; 
    }
    
    /** Checks whether the 'basesTrimmedFromEnd' field has been set */
    public boolean hasBasesTrimmedFromEnd() {
      return fieldSetFlags()[12];
    }
    
    /** Clears the value of the 'basesTrimmedFromEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearBasesTrimmedFromEnd() {
      basesTrimmedFromEnd = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /** Gets the value of the 'readPaired' field */
    public java.lang.Boolean getReadPaired() {
      return readPaired;
    }
    
    /** Sets the value of the 'readPaired' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadPaired(java.lang.Boolean value) {
      validate(fields()[13], value);
      this.readPaired = value;
      fieldSetFlags()[13] = true;
      return this; 
    }
    
    /** Checks whether the 'readPaired' field has been set */
    public boolean hasReadPaired() {
      return fieldSetFlags()[13];
    }
    
    /** Clears the value of the 'readPaired' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadPaired() {
      readPaired = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /** Gets the value of the 'properPair' field */
    public java.lang.Boolean getProperPair() {
      return properPair;
    }
    
    /** Sets the value of the 'properPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setProperPair(java.lang.Boolean value) {
      validate(fields()[14], value);
      this.properPair = value;
      fieldSetFlags()[14] = true;
      return this; 
    }
    
    /** Checks whether the 'properPair' field has been set */
    public boolean hasProperPair() {
      return fieldSetFlags()[14];
    }
    
    /** Clears the value of the 'properPair' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearProperPair() {
      properPair = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /** Gets the value of the 'readMapped' field */
    public java.lang.Boolean getReadMapped() {
      return readMapped;
    }
    
    /** Sets the value of the 'readMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadMapped(java.lang.Boolean value) {
      validate(fields()[15], value);
      this.readMapped = value;
      fieldSetFlags()[15] = true;
      return this; 
    }
    
    /** Checks whether the 'readMapped' field has been set */
    public boolean hasReadMapped() {
      return fieldSetFlags()[15];
    }
    
    /** Clears the value of the 'readMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadMapped() {
      readMapped = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    /** Gets the value of the 'mateMapped' field */
    public java.lang.Boolean getMateMapped() {
      return mateMapped;
    }
    
    /** Sets the value of the 'mateMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateMapped(java.lang.Boolean value) {
      validate(fields()[16], value);
      this.mateMapped = value;
      fieldSetFlags()[16] = true;
      return this; 
    }
    
    /** Checks whether the 'mateMapped' field has been set */
    public boolean hasMateMapped() {
      return fieldSetFlags()[16];
    }
    
    /** Clears the value of the 'mateMapped' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateMapped() {
      mateMapped = null;
      fieldSetFlags()[16] = false;
      return this;
    }

    /** Gets the value of the 'failedVendorQualityChecks' field */
    public java.lang.Boolean getFailedVendorQualityChecks() {
      return failedVendorQualityChecks;
    }
    
    /** Sets the value of the 'failedVendorQualityChecks' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setFailedVendorQualityChecks(java.lang.Boolean value) {
      validate(fields()[17], value);
      this.failedVendorQualityChecks = value;
      fieldSetFlags()[17] = true;
      return this; 
    }
    
    /** Checks whether the 'failedVendorQualityChecks' field has been set */
    public boolean hasFailedVendorQualityChecks() {
      return fieldSetFlags()[17];
    }
    
    /** Clears the value of the 'failedVendorQualityChecks' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearFailedVendorQualityChecks() {
      failedVendorQualityChecks = null;
      fieldSetFlags()[17] = false;
      return this;
    }

    /** Gets the value of the 'duplicateRead' field */
    public java.lang.Boolean getDuplicateRead() {
      return duplicateRead;
    }
    
    /** Sets the value of the 'duplicateRead' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setDuplicateRead(java.lang.Boolean value) {
      validate(fields()[18], value);
      this.duplicateRead = value;
      fieldSetFlags()[18] = true;
      return this; 
    }
    
    /** Checks whether the 'duplicateRead' field has been set */
    public boolean hasDuplicateRead() {
      return fieldSetFlags()[18];
    }
    
    /** Clears the value of the 'duplicateRead' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearDuplicateRead() {
      duplicateRead = null;
      fieldSetFlags()[18] = false;
      return this;
    }

    /** Gets the value of the 'readNegativeStrand' field */
    public java.lang.Boolean getReadNegativeStrand() {
      return readNegativeStrand;
    }
    
    /** Sets the value of the 'readNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setReadNegativeStrand(java.lang.Boolean value) {
      validate(fields()[19], value);
      this.readNegativeStrand = value;
      fieldSetFlags()[19] = true;
      return this; 
    }
    
    /** Checks whether the 'readNegativeStrand' field has been set */
    public boolean hasReadNegativeStrand() {
      return fieldSetFlags()[19];
    }
    
    /** Clears the value of the 'readNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearReadNegativeStrand() {
      readNegativeStrand = null;
      fieldSetFlags()[19] = false;
      return this;
    }

    /** Gets the value of the 'mateNegativeStrand' field */
    public java.lang.Boolean getMateNegativeStrand() {
      return mateNegativeStrand;
    }
    
    /** Sets the value of the 'mateNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateNegativeStrand(java.lang.Boolean value) {
      validate(fields()[20], value);
      this.mateNegativeStrand = value;
      fieldSetFlags()[20] = true;
      return this; 
    }
    
    /** Checks whether the 'mateNegativeStrand' field has been set */
    public boolean hasMateNegativeStrand() {
      return fieldSetFlags()[20];
    }
    
    /** Clears the value of the 'mateNegativeStrand' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateNegativeStrand() {
      mateNegativeStrand = null;
      fieldSetFlags()[20] = false;
      return this;
    }

    /** Gets the value of the 'primaryAlignment' field */
    public java.lang.Boolean getPrimaryAlignment() {
      return primaryAlignment;
    }
    
    /** Sets the value of the 'primaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setPrimaryAlignment(java.lang.Boolean value) {
      validate(fields()[21], value);
      this.primaryAlignment = value;
      fieldSetFlags()[21] = true;
      return this; 
    }
    
    /** Checks whether the 'primaryAlignment' field has been set */
    public boolean hasPrimaryAlignment() {
      return fieldSetFlags()[21];
    }
    
    /** Clears the value of the 'primaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearPrimaryAlignment() {
      primaryAlignment = null;
      fieldSetFlags()[21] = false;
      return this;
    }

    /** Gets the value of the 'secondaryAlignment' field */
    public java.lang.Boolean getSecondaryAlignment() {
      return secondaryAlignment;
    }
    
    /** Sets the value of the 'secondaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSecondaryAlignment(java.lang.Boolean value) {
      validate(fields()[22], value);
      this.secondaryAlignment = value;
      fieldSetFlags()[22] = true;
      return this; 
    }
    
    /** Checks whether the 'secondaryAlignment' field has been set */
    public boolean hasSecondaryAlignment() {
      return fieldSetFlags()[22];
    }
    
    /** Clears the value of the 'secondaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSecondaryAlignment() {
      secondaryAlignment = null;
      fieldSetFlags()[22] = false;
      return this;
    }

    /** Gets the value of the 'supplementaryAlignment' field */
    public java.lang.Boolean getSupplementaryAlignment() {
      return supplementaryAlignment;
    }
    
    /** Sets the value of the 'supplementaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setSupplementaryAlignment(java.lang.Boolean value) {
      validate(fields()[23], value);
      this.supplementaryAlignment = value;
      fieldSetFlags()[23] = true;
      return this; 
    }
    
    /** Checks whether the 'supplementaryAlignment' field has been set */
    public boolean hasSupplementaryAlignment() {
      return fieldSetFlags()[23];
    }
    
    /** Clears the value of the 'supplementaryAlignment' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearSupplementaryAlignment() {
      supplementaryAlignment = null;
      fieldSetFlags()[23] = false;
      return this;
    }

    /** Gets the value of the 'mismatchingPositions' field */
    public java.lang.CharSequence getMismatchingPositions() {
      return mismatchingPositions;
    }
    
    /** Sets the value of the 'mismatchingPositions' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMismatchingPositions(java.lang.CharSequence value) {
      validate(fields()[24], value);
      this.mismatchingPositions = value;
      fieldSetFlags()[24] = true;
      return this; 
    }
    
    /** Checks whether the 'mismatchingPositions' field has been set */
    public boolean hasMismatchingPositions() {
      return fieldSetFlags()[24];
    }
    
    /** Clears the value of the 'mismatchingPositions' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMismatchingPositions() {
      mismatchingPositions = null;
      fieldSetFlags()[24] = false;
      return this;
    }

    /** Gets the value of the 'origQual' field */
    public java.lang.CharSequence getOrigQual() {
      return origQual;
    }
    
    /** Sets the value of the 'origQual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setOrigQual(java.lang.CharSequence value) {
      validate(fields()[25], value);
      this.origQual = value;
      fieldSetFlags()[25] = true;
      return this; 
    }
    
    /** Checks whether the 'origQual' field has been set */
    public boolean hasOrigQual() {
      return fieldSetFlags()[25];
    }
    
    /** Clears the value of the 'origQual' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearOrigQual() {
      origQual = null;
      fieldSetFlags()[25] = false;
      return this;
    }

    /** Gets the value of the 'attributes' field */
    public java.lang.CharSequence getAttributes() {
      return attributes;
    }
    
    /** Sets the value of the 'attributes' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setAttributes(java.lang.CharSequence value) {
      validate(fields()[26], value);
      this.attributes = value;
      fieldSetFlags()[26] = true;
      return this; 
    }
    
    /** Checks whether the 'attributes' field has been set */
    public boolean hasAttributes() {
      return fieldSetFlags()[26];
    }
    
    /** Clears the value of the 'attributes' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearAttributes() {
      attributes = null;
      fieldSetFlags()[26] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupName' field */
    public java.lang.CharSequence getRecordGroupName() {
      return recordGroupName;
    }
    
    /** Sets the value of the 'recordGroupName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupName(java.lang.CharSequence value) {
      validate(fields()[27], value);
      this.recordGroupName = value;
      fieldSetFlags()[27] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupName' field has been set */
    public boolean hasRecordGroupName() {
      return fieldSetFlags()[27];
    }
    
    /** Clears the value of the 'recordGroupName' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupName() {
      recordGroupName = null;
      fieldSetFlags()[27] = false;
      return this;
    }

    /** Gets the value of the 'recordGroupSample' field */
    public java.lang.CharSequence getRecordGroupSample() {
      return recordGroupSample;
    }
    
    /** Sets the value of the 'recordGroupSample' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setRecordGroupSample(java.lang.CharSequence value) {
      validate(fields()[28], value);
      this.recordGroupSample = value;
      fieldSetFlags()[28] = true;
      return this; 
    }
    
    /** Checks whether the 'recordGroupSample' field has been set */
    public boolean hasRecordGroupSample() {
      return fieldSetFlags()[28];
    }
    
    /** Clears the value of the 'recordGroupSample' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearRecordGroupSample() {
      recordGroupSample = null;
      fieldSetFlags()[28] = false;
      return this;
    }

    /** Gets the value of the 'mateAlignmentStart' field */
    public java.lang.Long getMateAlignmentStart() {
      return mateAlignmentStart;
    }
    
    /** Sets the value of the 'mateAlignmentStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateAlignmentStart(java.lang.Long value) {
      validate(fields()[29], value);
      this.mateAlignmentStart = value;
      fieldSetFlags()[29] = true;
      return this; 
    }
    
    /** Checks whether the 'mateAlignmentStart' field has been set */
    public boolean hasMateAlignmentStart() {
      return fieldSetFlags()[29];
    }
    
    /** Clears the value of the 'mateAlignmentStart' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateAlignmentStart() {
      mateAlignmentStart = null;
      fieldSetFlags()[29] = false;
      return this;
    }

    /** Gets the value of the 'mateAlignmentEnd' field */
    public java.lang.Long getMateAlignmentEnd() {
      return mateAlignmentEnd;
    }
    
    /** Sets the value of the 'mateAlignmentEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateAlignmentEnd(java.lang.Long value) {
      validate(fields()[30], value);
      this.mateAlignmentEnd = value;
      fieldSetFlags()[30] = true;
      return this; 
    }
    
    /** Checks whether the 'mateAlignmentEnd' field has been set */
    public boolean hasMateAlignmentEnd() {
      return fieldSetFlags()[30];
    }
    
    /** Clears the value of the 'mateAlignmentEnd' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateAlignmentEnd() {
      mateAlignmentEnd = null;
      fieldSetFlags()[30] = false;
      return this;
    }

    /** Gets the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.Contig getMateContig() {
      return mateContig;
    }
    
    /** Sets the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setMateContig(org.bdgenomics.formats.avro.Contig value) {
      validate(fields()[31], value);
      this.mateContig = value;
      fieldSetFlags()[31] = true;
      return this; 
    }
    
    /** Checks whether the 'mateContig' field has been set */
    public boolean hasMateContig() {
      return fieldSetFlags()[31];
    }
    
    /** Clears the value of the 'mateContig' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearMateContig() {
      mateContig = null;
      fieldSetFlags()[31] = false;
      return this;
    }

    /** Gets the value of the 'inferredInsertSize' field */
    public java.lang.Long getInferredInsertSize() {
      return inferredInsertSize;
    }
    
    /** Sets the value of the 'inferredInsertSize' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder setInferredInsertSize(java.lang.Long value) {
      validate(fields()[32], value);
      this.inferredInsertSize = value;
      fieldSetFlags()[32] = true;
      return this; 
    }
    
    /** Checks whether the 'inferredInsertSize' field has been set */
    public boolean hasInferredInsertSize() {
      return fieldSetFlags()[32];
    }
    
    /** Clears the value of the 'inferredInsertSize' field */
    public org.bdgenomics.formats.avro.AlignmentRecord.Builder clearInferredInsertSize() {
      inferredInsertSize = null;
      fieldSetFlags()[32] = false;
      return this;
    }

    @Override
    public AlignmentRecord build() {
      try {
        AlignmentRecord record = new AlignmentRecord();
        record.readInFragment = fieldSetFlags()[0] ? this.readInFragment : (java.lang.Integer) defaultValue(fields()[0]);
        record.contig = fieldSetFlags()[1] ? this.contig : (org.bdgenomics.formats.avro.Contig) defaultValue(fields()[1]);
        record.start = fieldSetFlags()[2] ? this.start : (java.lang.Long) defaultValue(fields()[2]);
        record.oldPosition = fieldSetFlags()[3] ? this.oldPosition : (java.lang.Long) defaultValue(fields()[3]);
        record.end = fieldSetFlags()[4] ? this.end : (java.lang.Long) defaultValue(fields()[4]);
        record.mapq = fieldSetFlags()[5] ? this.mapq : (java.lang.Integer) defaultValue(fields()[5]);
        record.readName = fieldSetFlags()[6] ? this.readName : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.sequence = fieldSetFlags()[7] ? this.sequence : (java.lang.CharSequence) defaultValue(fields()[7]);
        record.qual = fieldSetFlags()[8] ? this.qual : (java.lang.CharSequence) defaultValue(fields()[8]);
        record.cigar = fieldSetFlags()[9] ? this.cigar : (java.lang.CharSequence) defaultValue(fields()[9]);
        record.oldCigar = fieldSetFlags()[10] ? this.oldCigar : (java.lang.CharSequence) defaultValue(fields()[10]);
        record.basesTrimmedFromStart = fieldSetFlags()[11] ? this.basesTrimmedFromStart : (java.lang.Integer) defaultValue(fields()[11]);
        record.basesTrimmedFromEnd = fieldSetFlags()[12] ? this.basesTrimmedFromEnd : (java.lang.Integer) defaultValue(fields()[12]);
        record.readPaired = fieldSetFlags()[13] ? this.readPaired : (java.lang.Boolean) defaultValue(fields()[13]);
        record.properPair = fieldSetFlags()[14] ? this.properPair : (java.lang.Boolean) defaultValue(fields()[14]);
        record.readMapped = fieldSetFlags()[15] ? this.readMapped : (java.lang.Boolean) defaultValue(fields()[15]);
        record.mateMapped = fieldSetFlags()[16] ? this.mateMapped : (java.lang.Boolean) defaultValue(fields()[16]);
        record.failedVendorQualityChecks = fieldSetFlags()[17] ? this.failedVendorQualityChecks : (java.lang.Boolean) defaultValue(fields()[17]);
        record.duplicateRead = fieldSetFlags()[18] ? this.duplicateRead : (java.lang.Boolean) defaultValue(fields()[18]);
        record.readNegativeStrand = fieldSetFlags()[19] ? this.readNegativeStrand : (java.lang.Boolean) defaultValue(fields()[19]);
        record.mateNegativeStrand = fieldSetFlags()[20] ? this.mateNegativeStrand : (java.lang.Boolean) defaultValue(fields()[20]);
        record.primaryAlignment = fieldSetFlags()[21] ? this.primaryAlignment : (java.lang.Boolean) defaultValue(fields()[21]);
        record.secondaryAlignment = fieldSetFlags()[22] ? this.secondaryAlignment : (java.lang.Boolean) defaultValue(fields()[22]);
        record.supplementaryAlignment = fieldSetFlags()[23] ? this.supplementaryAlignment : (java.lang.Boolean) defaultValue(fields()[23]);
        record.mismatchingPositions = fieldSetFlags()[24] ? this.mismatchingPositions : (java.lang.CharSequence) defaultValue(fields()[24]);
        record.origQual = fieldSetFlags()[25] ? this.origQual : (java.lang.CharSequence) defaultValue(fields()[25]);
        record.attributes = fieldSetFlags()[26] ? this.attributes : (java.lang.CharSequence) defaultValue(fields()[26]);
        record.recordGroupName = fieldSetFlags()[27] ? this.recordGroupName : (java.lang.CharSequence) defaultValue(fields()[27]);
        record.recordGroupSample = fieldSetFlags()[28] ? this.recordGroupSample : (java.lang.CharSequence) defaultValue(fields()[28]);
        record.mateAlignmentStart = fieldSetFlags()[29] ? this.mateAlignmentStart : (java.lang.Long) defaultValue(fields()[29]);
        record.mateAlignmentEnd = fieldSetFlags()[30] ? this.mateAlignmentEnd : (java.lang.Long) defaultValue(fields()[30]);
        record.mateContig = fieldSetFlags()[31] ? this.mateContig : (org.bdgenomics.formats.avro.Contig) defaultValue(fields()[31]);
        record.inferredInsertSize = fieldSetFlags()[32] ? this.inferredInsertSize : (java.lang.Long) defaultValue(fields()[32]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
