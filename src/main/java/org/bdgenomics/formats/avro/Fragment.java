/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
package org.bdgenomics.formats.avro;  
@SuppressWarnings("all")
/** The DNA fragment that is was targeted by the sequencer, resulting in
   one or more reads. */
@org.apache.avro.specific.AvroGenerated
public class Fragment extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Fragment\",\"namespace\":\"org.bdgenomics.formats.avro\",\"doc\":\"The DNA fragment that is was targeted by the sequencer, resulting in\\n   one or more reads.\",\"fields\":[{\"name\":\"readName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this Fragment.\",\"default\":null},{\"name\":\"instrument\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"runId\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"fragmentSize\",\"type\":[\"null\",\"int\"],\"doc\":\"Fragment's insert size derived from alignment, if the reads have been\\n   aligned.\",\"default\":null},{\"name\":\"alignments\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"AlignmentRecord\",\"fields\":[{\"name\":\"readInFragment\",\"type\":[\"int\",\"null\"],\"doc\":\"Read number within the array of fragment reads.\",\"default\":0},{\"name\":\"contig\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"Contig\",\"doc\":\"Record for describing a reference assembly. Not used for storing the contents\\n of said assembly.\\n\\n @see NucleotideContigFragment\",\"fields\":[{\"name\":\"contigName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this contig in the assembly (e.g., \\\"chr1\\\").\",\"default\":null},{\"name\":\"contigLength\",\"type\":[\"null\",\"long\"],\"doc\":\"The length of this contig.\",\"default\":null},{\"name\":\"contigMD5\",\"type\":[\"null\",\"string\"],\"doc\":\"The MD5 checksum of the assembly for this contig.\",\"default\":null},{\"name\":\"referenceURL\",\"type\":[\"null\",\"string\"],\"doc\":\"The URL at which this reference assembly can be found.\",\"default\":null},{\"name\":\"assembly\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this assembly (e.g., \\\"hg19\\\").\",\"default\":null},{\"name\":\"species\",\"type\":[\"null\",\"string\"],\"doc\":\"The species that this assembly is for.\",\"default\":null},{\"name\":\"referenceIndex\",\"type\":[\"null\",\"int\"],\"doc\":\"Optional 0-based index of this contig in a SAM file header that it was read\\n   from; helps output SAMs/BAMs with headers in the same order as they started\\n   with, before a conversion to ADAM.\",\"default\":null}]}],\"doc\":\"The reference sequence details for the reference chromosome that\\n   this read is aligned to. If the read is unaligned, this field should\\n   be null.\",\"default\":null},{\"name\":\"start\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the start of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"oldPosition\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position where this read used to start before\\n   local realignment.\\n   Stores the same data as the OP field in the SAM format.\",\"default\":null},{\"name\":\"end\",\"type\":[\"null\",\"long\"],\"doc\":\"0 based reference position for the end of this read's alignment.\\n   Should be null if the read is unaligned.\",\"default\":null},{\"name\":\"mapq\",\"type\":[\"null\",\"int\"],\"doc\":\"The global mapping quality of this read.\",\"default\":null},{\"name\":\"readName\",\"type\":[\"null\",\"string\"],\"doc\":\"The name of this read. This should be unique within the read group\\n   that this read is from, and can be used to identify other reads that\\n   are derived from a single fragment.\",\"default\":null},{\"name\":\"sequence\",\"type\":[\"null\",\"string\"],\"doc\":\"The bases in this alignment. If the read has been hard clipped, this may\\n   not represent all the bases in the original read.\",\"default\":null},{\"name\":\"qual\",\"type\":[\"null\",\"string\"],\"doc\":\"The per-base quality scores in this alignment. If the read has been hard\\n   clipped, this may not represent all the bases in the original read.\\n   Additionally, if the error scores have been recalibrated, this field\\n   will not contain the original base quality scores.\\n\\n   @see origQual\",\"default\":null},{\"name\":\"cigar\",\"type\":[\"null\",\"string\"],\"doc\":\"The Compact Ideosyncratic Gapped Alignment Report (CIGAR) string that\\n   describes the local alignment of this read. Contains {length, operator}\\n   pairs for all contiguous alignment operations. The operators include:\\n\\n   * M, ALIGNMENT_MATCH: An alignment match indicates that a sequence can be\\n     aligned to the reference without evidence of an INDEL. Unlike the\\n     SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the ALIGNMENT_MATCH\\n     operator does not indicate whether the reference and read sequences are an\\n     exact match.\\n   * I, INSERT: The insert operator indicates that the read contains evidence of\\n     bases being inserted into the reference.\\n   * D, DELETE: The delete operator indicates that the read contains evidence of\\n     bases being deleted from the reference.\\n   * N, SKIP: The skip operator indicates that this read skips a long segment of\\n     the reference, but the bases have not been deleted. This operator is\\n     commonly used when working with RNA-seq data, where reads may skip long\\n     segments of the reference between exons.\\n   * S, CLIP_SOFT: The soft clip operator indicates that bases at the start/end\\n     of a read have not been considered during alignment. This may occur if the\\n     majority of a read maps, except for low quality bases at the start/end of\\n     a read. Bases that are soft clipped will still be stored in the read.\\n   * H, CLIP_HARD: The hard clip operator indicates that bases at the start/end of\\n     a read have been omitted from this alignment. This may occur if this linear\\n     alignment is part of a chimeric alignment, or if the read has been trimmed\\n     (e.g., during error correction, or to trim poly-A tails for RNA-seq).\\n   * P, PAD: The pad operator indicates that there is padding in an alignment.\\n   * =, SEQUENCE_MATCH: This operator indicates that this portion of the aligned\\n     sequence exactly matches the reference (e.g., all bases are equal to the\\n     reference bases).\\n   * X, SEQUENCE_MISMATCH: This operator indicates that this portion of the\\n     aligned sequence is an alignment match to the reference, but a sequence\\n     mismatch (e.g., the bases are not equal to the reference). This can\\n     indicate a SNP or a read error.\",\"default\":null},{\"name\":\"oldCigar\",\"type\":[\"null\",\"string\"],\"doc\":\"Stores the CIGAR string present before local indel realignment.\\n   Stores the same data as the OC field in the SAM format.\\n\\n   @see cigar\",\"default\":null},{\"name\":\"basesTrimmedFromStart\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   start of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the start of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"basesTrimmedFromEnd\",\"type\":[\"int\",\"null\"],\"doc\":\"The number of bases in this read/alignment that have been trimmed from the\\n   end of the read. By default, this is equal to 0. If the value is non-zero,\\n   that means that the end of the read has been hard-clipped.\\n\\n   @see cigar\",\"default\":0},{\"name\":\"readPaired\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"properPair\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"mateMapped\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"failedVendorQualityChecks\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"duplicateRead\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"readNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if this alignment is mapped as a reverse compliment. This field\\n   defaults to false.\",\"default\":false},{\"name\":\"mateNegativeStrand\",\"type\":[\"boolean\",\"null\"],\"doc\":\"True if the mate pair of this alignment is mapped as a reverse compliment.\\n   This field defaults to false.\",\"default\":false},{\"name\":\"primaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is either the best linear alignment,\\n   or the first linear alignment in a chimeric alignment. Defaults to false.\\n\\n   @see secondaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"secondaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a lower quality linear alignment\\n   for a multiply-mapped read. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see supplementaryAlignment\",\"default\":false},{\"name\":\"supplementaryAlignment\",\"type\":[\"boolean\",\"null\"],\"doc\":\"This field is true if this alignment is a non-primary linear alignment"," in\\n   a chimeric alignment. Defaults to false.\\n\\n   @see primaryAlignment\\n   @see secondaryAlignment\",\"default\":false},{\"name\":\"mismatchingPositions\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"origQual\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"attributes\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"recordGroupSample\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"mateAlignmentStart\",\"type\":[\"null\",\"long\"],\"doc\":\"The start position of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateAlignmentEnd\",\"type\":[\"null\",\"long\"],\"doc\":\"The end position of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"mateContig\",\"type\":[\"null\",\"Contig\"],\"doc\":\"The reference contig of the mate of this read. Should be set to null if the\\n   mate is unaligned, or if the mate does not exist.\",\"default\":null},{\"name\":\"inferredInsertSize\",\"type\":[\"null\",\"long\"],\"doc\":\"The distance between this read and it's mate as inferred from alignment.\",\"default\":null}]}},\"doc\":\"The sequences read from this fragment.\",\"default\":[]}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The name of this Fragment. */
  @Deprecated public java.lang.CharSequence readName;
  @Deprecated public java.lang.CharSequence instrument;
  @Deprecated public java.lang.CharSequence runId;
  /** Fragment's insert size derived from alignment, if the reads have been
   aligned. */
  @Deprecated public java.lang.Integer fragmentSize;
  /** The sequences read from this fragment. */
  @Deprecated public java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> alignments;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>. 
   */
  public Fragment() {}

  /**
   * All-args constructor.
   */
  public Fragment(java.lang.CharSequence readName, java.lang.CharSequence instrument, java.lang.CharSequence runId, java.lang.Integer fragmentSize, java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> alignments) {
    this.readName = readName;
    this.instrument = instrument;
    this.runId = runId;
    this.fragmentSize = fragmentSize;
    this.alignments = alignments;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call. 
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return readName;
    case 1: return instrument;
    case 2: return runId;
    case 3: return fragmentSize;
    case 4: return alignments;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }
  // Used by DatumReader.  Applications should not call. 
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: readName = (java.lang.CharSequence)value$; break;
    case 1: instrument = (java.lang.CharSequence)value$; break;
    case 2: runId = (java.lang.CharSequence)value$; break;
    case 3: fragmentSize = (java.lang.Integer)value$; break;
    case 4: alignments = (java.util.List<org.bdgenomics.formats.avro.AlignmentRecord>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'readName' field.
   * The name of this Fragment.   */
  public java.lang.CharSequence getReadName() {
    return readName;
  }

  /**
   * Sets the value of the 'readName' field.
   * The name of this Fragment.   * @param value the value to set.
   */
  public void setReadName(java.lang.CharSequence value) {
    this.readName = value;
  }

  /**
   * Gets the value of the 'instrument' field.
   */
  public java.lang.CharSequence getInstrument() {
    return instrument;
  }

  /**
   * Sets the value of the 'instrument' field.
   * @param value the value to set.
   */
  public void setInstrument(java.lang.CharSequence value) {
    this.instrument = value;
  }

  /**
   * Gets the value of the 'runId' field.
   */
  public java.lang.CharSequence getRunId() {
    return runId;
  }

  /**
   * Sets the value of the 'runId' field.
   * @param value the value to set.
   */
  public void setRunId(java.lang.CharSequence value) {
    this.runId = value;
  }

  /**
   * Gets the value of the 'fragmentSize' field.
   * Fragment's insert size derived from alignment, if the reads have been
   aligned.   */
  public java.lang.Integer getFragmentSize() {
    return fragmentSize;
  }

  /**
   * Sets the value of the 'fragmentSize' field.
   * Fragment's insert size derived from alignment, if the reads have been
   aligned.   * @param value the value to set.
   */
  public void setFragmentSize(java.lang.Integer value) {
    this.fragmentSize = value;
  }

  /**
   * Gets the value of the 'alignments' field.
   * The sequences read from this fragment.   */
  public java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> getAlignments() {
    return alignments;
  }

  /**
   * Sets the value of the 'alignments' field.
   * The sequences read from this fragment.   * @param value the value to set.
   */
  public void setAlignments(java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> value) {
    this.alignments = value;
  }

  /** Creates a new Fragment RecordBuilder */
  public static org.bdgenomics.formats.avro.Fragment.Builder newBuilder() {
    return new org.bdgenomics.formats.avro.Fragment.Builder();
  }
  
  /** Creates a new Fragment RecordBuilder by copying an existing Builder */
  public static org.bdgenomics.formats.avro.Fragment.Builder newBuilder(org.bdgenomics.formats.avro.Fragment.Builder other) {
    return new org.bdgenomics.formats.avro.Fragment.Builder(other);
  }
  
  /** Creates a new Fragment RecordBuilder by copying an existing Fragment instance */
  public static org.bdgenomics.formats.avro.Fragment.Builder newBuilder(org.bdgenomics.formats.avro.Fragment other) {
    return new org.bdgenomics.formats.avro.Fragment.Builder(other);
  }
  
  /**
   * RecordBuilder for Fragment instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<Fragment>
    implements org.apache.avro.data.RecordBuilder<Fragment> {

    private java.lang.CharSequence readName;
    private java.lang.CharSequence instrument;
    private java.lang.CharSequence runId;
    private java.lang.Integer fragmentSize;
    private java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> alignments;

    /** Creates a new Builder */
    private Builder() {
      super(org.bdgenomics.formats.avro.Fragment.SCHEMA$);
    }
    
    /** Creates a Builder by copying an existing Builder */
    private Builder(org.bdgenomics.formats.avro.Fragment.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.readName)) {
        this.readName = data().deepCopy(fields()[0].schema(), other.readName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.instrument)) {
        this.instrument = data().deepCopy(fields()[1].schema(), other.instrument);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.runId)) {
        this.runId = data().deepCopy(fields()[2].schema(), other.runId);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.fragmentSize)) {
        this.fragmentSize = data().deepCopy(fields()[3].schema(), other.fragmentSize);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.alignments)) {
        this.alignments = data().deepCopy(fields()[4].schema(), other.alignments);
        fieldSetFlags()[4] = true;
      }
    }
    
    /** Creates a Builder by copying an existing Fragment instance */
    private Builder(org.bdgenomics.formats.avro.Fragment other) {
            super(org.bdgenomics.formats.avro.Fragment.SCHEMA$);
      if (isValidValue(fields()[0], other.readName)) {
        this.readName = data().deepCopy(fields()[0].schema(), other.readName);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.instrument)) {
        this.instrument = data().deepCopy(fields()[1].schema(), other.instrument);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.runId)) {
        this.runId = data().deepCopy(fields()[2].schema(), other.runId);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.fragmentSize)) {
        this.fragmentSize = data().deepCopy(fields()[3].schema(), other.fragmentSize);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.alignments)) {
        this.alignments = data().deepCopy(fields()[4].schema(), other.alignments);
        fieldSetFlags()[4] = true;
      }
    }

    /** Gets the value of the 'readName' field */
    public java.lang.CharSequence getReadName() {
      return readName;
    }
    
    /** Sets the value of the 'readName' field */
    public org.bdgenomics.formats.avro.Fragment.Builder setReadName(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.readName = value;
      fieldSetFlags()[0] = true;
      return this; 
    }
    
    /** Checks whether the 'readName' field has been set */
    public boolean hasReadName() {
      return fieldSetFlags()[0];
    }
    
    /** Clears the value of the 'readName' field */
    public org.bdgenomics.formats.avro.Fragment.Builder clearReadName() {
      readName = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /** Gets the value of the 'instrument' field */
    public java.lang.CharSequence getInstrument() {
      return instrument;
    }
    
    /** Sets the value of the 'instrument' field */
    public org.bdgenomics.formats.avro.Fragment.Builder setInstrument(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.instrument = value;
      fieldSetFlags()[1] = true;
      return this; 
    }
    
    /** Checks whether the 'instrument' field has been set */
    public boolean hasInstrument() {
      return fieldSetFlags()[1];
    }
    
    /** Clears the value of the 'instrument' field */
    public org.bdgenomics.formats.avro.Fragment.Builder clearInstrument() {
      instrument = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /** Gets the value of the 'runId' field */
    public java.lang.CharSequence getRunId() {
      return runId;
    }
    
    /** Sets the value of the 'runId' field */
    public org.bdgenomics.formats.avro.Fragment.Builder setRunId(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.runId = value;
      fieldSetFlags()[2] = true;
      return this; 
    }
    
    /** Checks whether the 'runId' field has been set */
    public boolean hasRunId() {
      return fieldSetFlags()[2];
    }
    
    /** Clears the value of the 'runId' field */
    public org.bdgenomics.formats.avro.Fragment.Builder clearRunId() {
      runId = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /** Gets the value of the 'fragmentSize' field */
    public java.lang.Integer getFragmentSize() {
      return fragmentSize;
    }
    
    /** Sets the value of the 'fragmentSize' field */
    public org.bdgenomics.formats.avro.Fragment.Builder setFragmentSize(java.lang.Integer value) {
      validate(fields()[3], value);
      this.fragmentSize = value;
      fieldSetFlags()[3] = true;
      return this; 
    }
    
    /** Checks whether the 'fragmentSize' field has been set */
    public boolean hasFragmentSize() {
      return fieldSetFlags()[3];
    }
    
    /** Clears the value of the 'fragmentSize' field */
    public org.bdgenomics.formats.avro.Fragment.Builder clearFragmentSize() {
      fragmentSize = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /** Gets the value of the 'alignments' field */
    public java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> getAlignments() {
      return alignments;
    }
    
    /** Sets the value of the 'alignments' field */
    public org.bdgenomics.formats.avro.Fragment.Builder setAlignments(java.util.List<org.bdgenomics.formats.avro.AlignmentRecord> value) {
      validate(fields()[4], value);
      this.alignments = value;
      fieldSetFlags()[4] = true;
      return this; 
    }
    
    /** Checks whether the 'alignments' field has been set */
    public boolean hasAlignments() {
      return fieldSetFlags()[4];
    }
    
    /** Clears the value of the 'alignments' field */
    public org.bdgenomics.formats.avro.Fragment.Builder clearAlignments() {
      alignments = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    @Override
    public Fragment build() {
      try {
        Fragment record = new Fragment();
        record.readName = fieldSetFlags()[0] ? this.readName : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.instrument = fieldSetFlags()[1] ? this.instrument : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.runId = fieldSetFlags()[2] ? this.runId : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.fragmentSize = fieldSetFlags()[3] ? this.fragmentSize : (java.lang.Integer) defaultValue(fields()[3]);
        record.alignments = fieldSetFlags()[4] ? this.alignments : (java.util.List<org.bdgenomics.formats.avro.AlignmentRecord>) defaultValue(fields()[4]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }
}
